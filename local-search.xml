<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL连接错误：Error 1045</title>
    <link href="/2023/05/18/MySQL%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%EF%BC%9AError%201045%20Access%20denied%20for%20user%20&#39;username&#39;@&#39;host&#39;%20(using%20password%20YES)/"/>
    <url>/2023/05/18/MySQL%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%EF%BC%9AError%201045%20Access%20denied%20for%20user%20&#39;username&#39;@&#39;host&#39;%20(using%20password%20YES)/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL连接错误：Error-1045-Access-denied-for-user-‘username‘-’host’-using-password-YES"><a href="#MySQL连接错误：Error-1045-Access-denied-for-user-‘username‘-’host’-using-password-YES" class="headerlink" title="MySQL连接错误：Error 1045: Access denied for user ‘username‘@’host’ (using password: YES)"></a>MySQL连接错误：Error 1045: Access denied for user ‘username‘@’host’ (using password: YES)</h2><h5 id="最近在配置云数据库时，总是报这个错误。网上给出的答案是连接数据库时用户名或密码不正确导致的。可能的原因包括："><a href="#最近在配置云数据库时，总是报这个错误。网上给出的答案是连接数据库时用户名或密码不正确导致的。可能的原因包括：" class="headerlink" title="最近在配置云数据库时，总是报这个错误。网上给出的答案是连接数据库时用户名或密码不正确导致的。可能的原因包括："></a>最近在配置云数据库时，总是报这个错误。网上给出的答案是连接数据库时用户名或密码不正确导致的。可能的原因包括：</h5><ol><li><p>用户名或密码输入错误</p></li><li><p>用户名或密码被限制访问</p></li><li><p>数据库服务未启动</p><p>在自己电脑上使用Navicat,通过相同的账号密码连接成功了，以上问题一下就排查掉了</p></li><li><p>MySQL驱动程序未导入或版本不匹配</p><p>使用以下代码更新后依然报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/go-sql-driver/mysql<br></code></pre></td></tr></table></figure></li></ol><p>OK，虽然我没有通过以上办法解决问题，但通过上面的步骤应该能帮助你解决这个问题。</p><h5 id="梦回大一"><a href="#梦回大一" class="headerlink" title="梦回大一"></a>梦回大一</h5><p>我是怎么解决的呢？一开始是通过配置文件<code>.ini</code>来配置数据库的，使用的是<code>ini.MapTo()</code>来映射配置。后来直接在代码中写进配置，发现连通了。这说明配置文件中的密码没问题，会不会是加载配置文件除了问题呢？于是乎把加载到的配置参数打印出来，果不其然，密码错了（密码以<code>#</code>结尾，而打印出来的密码不带有<code>#</code>）。原因是：</p><blockquote><p>在使用ini.MapTo()函数将配置文件中的内容映射到结构体时，如果配置文件中的某些键名或键值以“#”开头，可能会导致MapTo()函数无法正确读取这些键名或键值。这是因为“#”在INI文件中被用作注释符号，表示后面的内容都是注释，不应该被解析。</p></blockquote><p>配置文件在Goland打开的检查的，没高亮提醒（期间提示我安装插件，我忽略了，QAQ），真倒霉。这不禁让我想起当年刚学C语言时，因为main函数敲成mian导致找bug找了一整天，也是因为粗心。不过不得不说，编辑器确实也是给代码质量提供了不少保障。</p><p>在使用ini.MapTo()函数将配置文件中的内容映射到结构体时，如果配置文件中的某些键名或键值以“#”开头，可能会导致MapTo()函数无法正确读取这些键名或键值。这是因为“#”在INI文件中被用作注释符号，表示后面的内容都是注释，不应该被解析。</p><p>要解决这个问题，可以尝试以下方法：</p><ol><li>修改配置文件</li></ol><p>可以将配置文件中以“#”开头的键名或键值改为其他字符。例如，将“#key &#x3D; value”改为“_key &#x3D; value”。</p><ol><li>使用其他INI解析库</li></ol><p>如果配置文件中的键名或键值不能修改，可以尝试使用其他INI解析库，例如go-ini或ini.v1。这些库可能支持更多的配置文件格式和特性，可以更好地解析包含“#”字符的键名或键值。</p><ol><li>手动解析配置文件</li></ol><p>如果以上方法都无法解决问题，可以尝试手动解析配置文件。可以使用bufio.Scanner读取文件内容，然后使用strings.Split()函数将每一行分割为键名和键值，再将它们映射到结构体中。手动解析虽然比较麻烦，但可以更精确地控制解析过程，并且可以处理更复杂的配置文件格式和特性。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>配置文件</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gin跨域问题</title>
    <link href="/2023/05/16/gin%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/16/gin%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="gin跨域问题"><a href="#gin跨域问题" class="headerlink" title="gin跨域问题"></a>gin跨域问题</h3><p>作为中间件使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> middleware<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Cors</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>method := context.Request.Method<br>context.Header(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br>context.Header(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;Content-Type,AccessToken,X-CSRF-Token, Authorization, Token&quot;</span>)<br>context.Header(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;POST, GET, OPTIONS&quot;</span>)<br>context.Header(<span class="hljs-string">&quot;Access-Control-Expose-Headers&quot;</span>, <span class="hljs-string">&quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;</span>)<br>context.Header(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>)<br><span class="hljs-keyword">if</span> method == <span class="hljs-string">&quot;OPTIONS&quot;</span> &#123;<br>context.AbortWithStatus(http.StatusNoContent)<br>&#125;<br>context.Next()<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过代码<code>r.Use(middleware.Cors())</code>来使用，但有一点要注意的是，中间件的使用要在路由注册前。否则，跨域中间件使用前注册的路由将不支持跨域。</p><p>像这样是不行的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := setting.Init()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>err = dao.InitMySQL(setting.Conf.MySQLConfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;init mysql failed, err:%v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>r := routers.SetupRouter()<span class="hljs-comment">//路由注册</span><br>r.Use(middleware.Cors())<span class="hljs-comment">//跨域中间件使用</span><br>err = r.Run(fmt.Sprintf(<span class="hljs-string">&quot;:%d&quot;</span>, setting.Conf.Port))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在路由注册的前使用跨域中间件，也可以用他来区分哪些路由支持跨域，哪些不支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetupRouter</span><span class="hljs-params">()</span></span> *gin.Engine &#123;<br>   r := gin.Default()<br><br>   r.Use(middleware.Cors())<br><br>   r.POST(<span class="hljs-string">&quot;login&quot;</span>, controller.Login)<br><br>   <span class="hljs-comment">// Ping test</span><br>   r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>      c.String(http.StatusOK, <span class="hljs-string">&quot;pong&quot;</span>)<br>   &#125;)<br><br>   <span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gin</tag>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的Slice的细节</title>
    <link href="/2023/05/16/Go%E4%B8%AD%E7%9A%84Slice%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <url>/2023/05/16/Go%E4%B8%AD%E7%9A%84Slice%E7%9A%84%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h2 id="Go中的Slice的细节"><a href="#Go中的Slice的细节" class="headerlink" title="Go中的Slice的细节"></a>Go中的Slice的细节</h2><h5 id="源码如下"><a href="#源码如下" class="headerlink" title="源码如下"></a>源码如下</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>array unsafe.Pointer  <span class="hljs-comment">//一个指向数组的指针</span><br><span class="hljs-built_in">len</span>   <span class="hljs-type">int</span>  <span class="hljs-comment">//切片内元素的数量</span><br><span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span>  <span class="hljs-comment">//切片的容量</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/image-20230516013739364.png" alt="image-20230516013739364"></p><p>Go语言是值传递，但一个切片作为参数传递时，会把slice的值复制到另一个slice</p><p><img src="/../img/image-20230516122844623.png" alt="image-20230516122844623"></p><p>通过以下代码可以看出s1作为参数传递给test1后，test1创建了新的副本来承接s1的值，s1和形参slice拥有不同的地址空间，但却拥有相同的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>fmt.Println(<span class="hljs-string">&quot;s1的地址:&quot;</span>, unsafe.Pointer(&amp;s1))  <span class="hljs-comment">//0xc000096060</span><br>fmt.Println(<span class="hljs-string">&quot;s1指向的数组:&quot;</span>, unsafe.Pointer(&amp;s1[<span class="hljs-number">0</span>]))    <span class="hljs-comment">//0xc0000b00f0 </span><br>    <span class="hljs-comment">//s1 cap: 10 s1 len: 1 </span><br>    fmt.Println(<span class="hljs-string">&quot;s1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(s1), <span class="hljs-string">&quot;s1 len:&quot;</span>, <span class="hljs-built_in">len</span>(s1))   <br>test1(s1)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">(s2 []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;形参地址:&quot;</span>, unsafe.Pointer(&amp;s2))    <span class="hljs-comment">//0xc000096078</span><br>fmt.Println(<span class="hljs-string">&quot;形参指向的数组:&quot;</span>, unsafe.Pointer(&amp;s2[<span class="hljs-number">0</span>]))<span class="hljs-comment">//0xc0000b00f0</span><br>    <span class="hljs-comment">//s2 cap: 10 s1 len: 1 </span><br>    fmt.Println(<span class="hljs-string">&quot;s2 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(s2), <span class="hljs-string">&quot;s1 len:&quot;</span>, <span class="hljs-built_in">len</span>(s2))<br>&#125;<br></code></pre></td></tr></table></figure><p>当在函数内对s2指向的数组进行修改时，也会引起s1的改变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>fmt.Println(<span class="hljs-string">&quot;s1修改前:&quot;</span>, s1)<span class="hljs-comment">//[0],int的初始值是0</span><br>test2(s1)<br>fmt.Println(<span class="hljs-string">&quot;s1修改后:&quot;</span>, s1)<span class="hljs-comment">//[1]</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test2</span><span class="hljs-params">(s2 []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;s2修改前:&quot;</span>, s2)<span class="hljs-comment">//[0]</span><br>s2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">2</span>)<br>fmt.Println(<span class="hljs-string">&quot;s2修改后:&quot;</span>, s2)<span class="hljs-comment">//[1,2]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>过程大致如下：</p><p><img src="/../img/image-20230516130425709.png" alt="image-20230516130425709"></p><h4 id="slice扩容机制"><a href="#slice扩容机制" class="headerlink" title="slice扩容机制"></a>slice扩容机制</h4><p>但slice的len等于cap时，使用append往slice追加元素会引发扩容。扩容会开辟一个新的空间，并把原来的数组的值拷贝到新空间。</p><ul><li>cap&lt;1024:新的空间大小是原来的两倍</li><li>cap&gt;1024:为避免浪费内存，新的空间比原来的大1&#x2F;4</li></ul><p>由于扩容后的slice指向的是新的数组，再修改数组上的值，不会引起原数组的改变了。</p><p>值得注意的是，slice的初始值cap过小的话，会频繁的引起扩容，这会带来一定的损耗，过大会引起空间浪费，因此需要合理的初始化slice。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>fmt.Println(<span class="hljs-string">&quot;s1修改前:&quot;</span>, s1)<span class="hljs-comment">//[0]</span><br>test3(s1)<br>fmt.Println(<span class="hljs-string">&quot;s1修改后:&quot;</span>, s1)<span class="hljs-comment">//[0]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test3</span><span class="hljs-params">(s2 []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;扩容前底层数组的地址：&quot;</span>, unsafe.Pointer(&amp;s2[<span class="hljs-number">0</span>])) <span class="hljs-comment">// 0xc0000160c0</span><br>fmt.Println(<span class="hljs-string">&quot;扩容前s2的地址：&quot;</span>, unsafe.Pointer(&amp;s2))  <span class="hljs-comment">// 0xc000004090</span><br>fmt.Println(s2)<span class="hljs-comment">//[0]</span><br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">2</span>)<br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">3</span>)<br>fmt.Println(<span class="hljs-string">&quot;扩容后底层数组的地址：&quot;</span>, unsafe.Pointer(&amp;s2[<span class="hljs-number">0</span>])) <span class="hljs-comment">//0xc00000e200</span><br>fmt.Println(<span class="hljs-string">&quot;扩容前s2的地址：&quot;</span>, unsafe.Pointer(&amp;s2))  <span class="hljs-comment">//0xc000004090</span><br>s2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>fmt.Println(s2)<span class="hljs-comment">//[1,2,3]</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>slice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A7%AF%E7%B4%AF/"/>
    <url>/2023/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构积累"><a href="#数据结构积累" class="headerlink" title="数据结构积累"></a>数据结构积累</h2><h3 id="链表篇"><a href="#链表篇" class="headerlink" title="链表篇"></a>链表篇</h3><h4 id="链表的遍历："><a href="#链表的遍历：" class="headerlink" title="链表的遍历："></a>链表的遍历：</h4><h5 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="1.层序遍历"></a>1.层序遍历</h5><p>依靠队列轻松实现</p><p><img src="D:\Blog\source\img\image-20230515132047472.png" alt="image-20230515132047472"></p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//存放结果的数组</span><br>    ans:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">//判断是否为空的二叉树</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">return</span> ans<br>    &#125;<br>    <span class="hljs-comment">//模拟队列的数组</span><br>    queue:=[]*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span>&#123;<br>        <span class="hljs-comment">//队列为空，循环结束</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue)==<span class="hljs-number">0</span>&#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-comment">//将队头的值加入数组</span><br>        ans=<span class="hljs-built_in">append</span>(ans,queue[<span class="hljs-number">0</span>].Val )<br>        <span class="hljs-comment">//将队头的左子节点加入队尾</span><br>        <span class="hljs-keyword">if</span> queue[<span class="hljs-number">0</span>].Left!=<span class="hljs-literal">nil</span>&#123;<br>            queue=<span class="hljs-built_in">append</span>(queue,queue[<span class="hljs-number">0</span>].Left)<br>        &#125;<br>        <span class="hljs-comment">//将队头的右子节点加入队尾</span><br>        <span class="hljs-keyword">if</span> queue[<span class="hljs-number">0</span>].Right!=<span class="hljs-literal">nil</span>&#123;<br>            queue=<span class="hljs-built_in">append</span>(queue,queue[<span class="hljs-number">0</span>].Right)<br>        &#125;<br>        <span class="hljs-comment">//队头取出</span><br>        queue=queue[<span class="hljs-number">1</span>:]<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分享实用的小工具</title>
    <link href="/2023/05/11/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"/>
    <url>/2023/05/11/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="绘图工具"><a href="#绘图工具" class="headerlink" title="绘图工具"></a>绘图工具</h3><p><a href="https://excalidraw.com/">https://excalidraw.com/</a></p><p>一个画风清新的在线小白板，操作简单易上手。还有丰富的素材库，轻轻松松绘出美观的流程图。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="/../img/image-20230512181343591.png" alt="image-20230512181343591"></p><h4 id="推荐几个计算机专业时常用到的素材库"><a href="#推荐几个计算机专业时常用到的素材库" class="headerlink" title="推荐几个计算机专业时常用到的素材库"></a>推荐几个计算机专业时常用到的素材库</h4><p>点击上图右上方素材库，进入素材库，然后点击浏览素材库。然后把下方库名复制到搜索框进行搜索，然后添加即可</p><h5 id="Algorithms-and-Data-Structures"><a href="#Algorithms-and-Data-Structures" class="headerlink" title="Algorithms and Data Structures"></a>Algorithms and Data Structures</h5><p><img src="/../img/image-20230512181854115.png" alt="image-20230512181854115"></p><p>这个素材库提供了多种数据结构的简图，包含了数组、链表、Map、树等等。平写算法题时可以用来梳理思路，或者写题解。</p><h5 id="Shapes-for-UML-amp-ER-Diagrams"><a href="#Shapes-for-UML-amp-ER-Diagrams" class="headerlink" title="Shapes for UML &amp; ER Diagrams"></a>Shapes for UML &amp; ER Diagrams</h5><p><img src="/../img/image-20230512182458083.png" alt="image-20230512182458083"></p><p>绘制用例图和ER图，做需求分析时也时常用到。</p>]]></content>
    
    
    <categories>
      
      <category>小工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>绘图工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitee使用简易教程</title>
    <link href="/2023/03/30/Gitee%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
    <url>/2023/03/30/Gitee%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Gitee使用简易教程"><a href="#Gitee使用简易教程" class="headerlink" title="Gitee使用简易教程"></a>Gitee使用简易教程</h3><p>老师要求在gitee上提交作业的，对于没使用过Gitee的同学来说，可能一开始会有点复杂。可以按照以下方式进行。</p><h5 id="1-在Gitee上新建仓库："><a href="#1-在Gitee上新建仓库：" class="headerlink" title="1.在Gitee上新建仓库："></a>1.在Gitee上新建仓库：</h5><p>1.登录后在屏幕的右上角有个加号，鼠标悬停出现“新建仓库”</p><p><img src="/../img/image-20230330130743940.png" alt="image-20230330130743940"></p><p>2.点击新建仓库，进入如下界面，编辑仓库的名称和路径即可，至于初始化，先都不选择，点击创建。</p><p><img src="/../img/image-20230330130919059.png" alt="image-20230330130919059"></p><p>创建成功后进入到如下界面：</p><p><img src="/../img/image-20230330140242916.png" alt="image-20230330140242916"></p><p><strong>这是官方的入门教程，里面的代码可以直接使用。但事先需要在自己电脑上安装git。不要关闭这个页面，后面会用到。先进行后面的操作。</strong></p><h5 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h5><p>如果已经安装，可以跳过。</p><p><a href="https://www.cnblogs.com/ybqjymy/p/17226628.html">参考连接</a></p><h5 id="3-提交"><a href="#3-提交" class="headerlink" title="3.提交"></a>3.提交</h5><p>按照老师的文档创建Vue项目，进入到该项目的目录下，右击空白处，选择“Git Bash Here”打开命令行。</p><p><img src="/../img/image-20230330131546570.png" alt="image-20230330131546570"></p><p>首先需要进行的是全局设置：正如先前提到，此处可以直接使用你自己创建Gitee仓库时,官方给出的代码，无需修改。格式如下，在Gitee上创建仓库后的教程里找到对应的代码复制到命令行即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>由于我之前安装过git,在按照老师的的文档生成作的项目已经是一个仓库了，所以我们没选择初始化。而是直接进行以下操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;commit login_demo&quot;</span><br>git remote add origin https://gitee.com/lin-yegui/demo.git //这里换成自己的项目路径<br>git push -u origin <span class="hljs-string">&quot;master&quot;</span><br></code></pre></td></tr></table></figure><p>如果你是先在本地完成项目的创建后下的git,在执行以上代码时，命令行会提醒你进行初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>初始化成功后执行以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><p>如果出现以下错误：</p><p><img src="/../img/image-20230330154513629.png" alt="image-20230330154513629"></p><p>执行以下代码，后再执行<code>git status</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-built_in">config</span> --global --<span class="hljs-keyword">add </span>safe.<span class="hljs-keyword">directory </span><span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><p>当看到类似如下界面时，问题就被解决了。</p><p><img src="/../img/image-20230330142029806.png" alt="image-20230330142029806"></p><p>用如下命令追踪所有新加入的文件，然后提交，提交的信息和双引号格外主义需要英文</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;本次提交的说明写在这里&quot;</span> <br></code></pre></td></tr></table></figure><p>然后合并到远程仓库：这里的也可以直接使用官方的入门教程里的代码。格式如下，在Gitee上创建仓库后的教程里找到对应的代码复制到命令行即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote add origin https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/lin-yegui/</span>demo.git <span class="hljs-regexp">//</span>这里换成自己的项目路径<br>git push -u origin <span class="hljs-string">&quot;master&quot;</span><br></code></pre></td></tr></table></figure><p>执行<code>git push -u origin &quot;master&quot;</code>后会弹出一个登录界面，输入你的gitee账号密码即可。</p><p>掌握以上内容基本上可以完成本次作业的提交了，关于git的使用还有很多，以后用到的时候再慢慢查吧。</p><p><a href="https://www.runoob.com/git/git-remote.html">菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程与进程的区别</title>
    <link href="/2023/03/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2023/03/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h3 id="理解线程与进程的区别"><a href="#理解线程与进程的区别" class="headerlink" title="理解线程与进程的区别"></a>理解线程与进程的区别</h3><p>进程：是操作系统进行资源分配和保护的单位。</p><p>线程：是处理器调度和分配的基本单位。</p><p>下图是一个进程的组成，一个进程通常包含一个或多个线程。</p><p><img src="/../img/image-20230228213607224.png" alt="image-20230228213607224"></p><p>可以直观的看出，线程的存在使得处理器调度时，同一进程内的线程调度只需要完成用户栈和核心栈等少部分资源的切换。与进程切换相比节省了很多开销。</p><h3 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>用户级线程是指线程的管理工作有应用程序来做，在用户空间内实现，因此内核不知道线程的存在，进程才是处理器的基本单位。用户线程的切换不会陷入操作系统，省去了用户态—内核态—用户态模式切换的开销，但一个用户级线程的阻塞将引起整个进程的阻塞。Jeckting技术可以让操作系统在发现进程将要进入等待态时，可以让用户级线程的调度器选择下一线程占有处理器运行。</p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>线程的调度和管理由在内核中实现，内核可感知线程的存在并且以线程为单位进行处理器调度，一个进程里的某个线程阻塞时，其他的线程仍可以被调度。但每次调度需要用户态—内核态—用户态模式切换的开销。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce是如何工作的？</title>
    <link href="/2023/03/11/MapReduce%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/"/>
    <url>/2023/03/11/MapReduce%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="MapReduce是如何工作的？"><a href="#MapReduce是如何工作的？" class="headerlink" title="MapReduce是如何工作的？"></a>MapReduce是如何工作的？</h2><h4 id="这篇主要是根据个人理解，就着原文的例子，对MapReduce的执行过程有个更加直观的感受。"><a href="#这篇主要是根据个人理解，就着原文的例子，对MapReduce的执行过程有个更加直观的感受。" class="headerlink" title="这篇主要是根据个人理解，就着原文的例子，对MapReduce的执行过程有个更加直观的感受。"></a>这篇主要是根据个人理解，就着原文的例子，对MapReduce的执行过程有个更加直观的感受。</h4><p><img src="/../img/image-20230311164022116.png"></p><ol><li><h5 id="创建程序副本"><a href="#创建程序副本" class="headerlink" title="创建程序副本"></a>创建程序副本</h5><p>用户程序首先调用的MapReduce库将输入文件分成M个数据片度，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量的程序副本。 </p></li><li><h5 id="为程序副本分配任务"><a href="#为程序副本分配任务" class="headerlink" title="为程序副本分配任务"></a>为程序副本分配任务</h5><p>这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是worker程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。</p></li><li><h5 id="执行Map函数"><a href="#执行Map函数" class="headerlink" title="执行Map函数"></a>执行Map函数</h5><p>被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key&#x2F;value pair，然后把key&#x2F;value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key&#x2F;value pair，并缓存在内存中。</p></li><li><h5 id="存储中间key-x2F-value-pair"><a href="#存储中间key-x2F-value-pair" class="headerlink" title="存储中间key&#x2F;value pair"></a>存储中间key&#x2F;value pair</h5><p>缓存中的key&#x2F;value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key&#x2F;value pair在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。</p></li><li><h5 id="聚合数据"><a href="#聚合数据" class="headerlink" title="聚合数据"></a>聚合数据</h5><p>当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</p></li><li><h5 id="执行Reduce函数"><a href="#执行Reduce函数" class="headerlink" title="执行Reduce函数"></a>执行Reduce函数</h5><p>Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。</p></li><li><h5 id="返回MapReduce调用"><a href="#返回MapReduce调用" class="headerlink" title="返回MapReduce调用"></a>返回MapReduce调用</h5><p>当所有的Map和Reduce任务都完成之后，master唤醒用户程序。在这个时候，在用户程序里的对MapReduce调用才返回。</p></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>计算一个大的文档集合中每个单词出现的次数，下面是伪代码段：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">map</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>, <span class="hljs-built_in">String</span> value):<br>    <span class="hljs-comment">// key: document name</span><br>    <span class="hljs-comment">// value: document contents</span><br>    <span class="hljs-keyword">for</span> each word w in value:<br>        <span class="hljs-title function_">EmitIntermediate</span>(w, “<span class="hljs-number">1</span>″);<br><span class="hljs-title function_">reduce</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>, Iterator values):<br>    <span class="hljs-comment">// key: a word</span><br>    <span class="hljs-comment">// values: a list of counts</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> each v in values:<br>        result += <span class="hljs-title function_">ParseInt</span>(v);<br>    <span class="hljs-title function_">Emit</span>(<span class="hljs-title function_">AsString</span>(result));<br></code></pre></td></tr></table></figure><p>有如下文本段</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d d f f g g <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> d c g <span class="hljs-selector-tag">b</span>&quot; <br></code></pre></td></tr></table></figure><p>假设这是份很大的数据，我们不得已将他分成更小的部分，以便我们的机器能够处理它</p><p>于是乎他被分成了两部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">key1   &quot;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d d&quot;<br>key2   &quot;f f g g <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> d c g <span class="hljs-selector-tag">b</span>&quot; <br></code></pre></td></tr></table></figure><p>按照MapReduce的计划，它们将被分到不同两个机子上存起来</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">ComputerA  &#123;key1,&quot;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d d&quot;&#125;<br>ComputerB  &#123;key2,&quot;f f g g <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> d c g <span class="hljs-selector-tag">b</span>&quot;&#125; <br></code></pre></td></tr></table></figure><p>当用户调用MapReduce时，会在集群中创建大量的worker程序副本和一个master</p><p>master会优先让存储有输入文件的机器执行map任务。该机器上的worker程序把数据片段传递给map执行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">ComputerA :&#123;key1,&quot;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d d&quot;&#125; ---&gt; workerA---&gt;map(key1,&quot;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d d&quot;)<br>ComputerB :&#123;key2,&quot;f f g g <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> d c g <span class="hljs-selector-tag">b</span>&quot;&#125; ---&gt; workerB---&gt;map(key2,&quot;f f g g <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> d c g <span class="hljs-selector-tag">b</span>&quot;)<br></code></pre></td></tr></table></figure><p>得到中间键值对：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>d</th><th>d</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><table><thead><tr><th>f</th><th>f</th><th>g</th><th>g</th><th>a</th><th>a</th><th>d</th><th>c</th><th>g</th><th>b</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>假设分区数量R为2，根据hash(key) mod R将得到</p><p>ComputerA ：</p><p>分区R1：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>分区R2：</p><table><thead><tr><th>d</th><th>d</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr></tbody></table><p>ComputerB ：</p><p>分区R1：</p><table><thead><tr><th>a</th><th>a</th><th>c</th><th>b</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>分区R2：</p><table><thead><tr><th>f</th><th>f</th><th>g</th><th>g</th><th>d</th><th>g</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>master程序把这些分区后的数据的存储位置告诉执行Reduce的worker,worker把自己分区内的中间key&#x2F;valie pair收集。全部收集后如下</p><p>Reduce worker1：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>a</th><th>a</th><th>c</th><th>b</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>Reduce worker2：</p><table><thead><tr><th>d</th><th>d</th><th>f</th><th>f</th><th>g</th><th>g</th><th>d</th><th>g</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>排序聚合后：有时候在执行map任务后就可以通过Combiner函数，在Reduce收集中间数据时便完成排序。</p><table><thead><tr><th>a</th><th>a</th><th>a</th><th>a</th><th>a</th><th>b</th><th>b</th><th>b</th><th>b</th><th>c</th><th>c</th><th>c</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><table><thead><tr><th>d</th><th>d</th><th>d</th><th>f</th><th>f</th><th>g</th><th>g</th><th>g</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>最后，以key:a value:{1,1,1,1,1}作为参数，交给Reduce。得到 a : 5</p><h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><p>有时候在执行map任务后就可以通过Combiner函数，在Reduce收集中间数据时便完成排序。部分的合并中间结果可以显著的提高一些MapReduce操作的速度。</p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
      <tag>执行过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统简介</title>
    <link href="/2023/03/10/6.824%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/03/10/6.824%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>这是个人在学习 <strong>MIT6.824 分布式系统</strong>时的个人总结。</p><h3 id="6-824-分布式系统"><a href="#6-824-分布式系统" class="headerlink" title="6.824 分布式系统"></a>6.824 分布式系统</h3><h5 id="分布式系统的核心：是一系列计算集群通过网络共同完成某一串连贯的任务"><a href="#分布式系统的核心：是一系列计算集群通过网络共同完成某一串连贯的任务" class="headerlink" title="分布式系统的核心：是一系列计算集群通过网络共同完成某一串连贯的任务"></a>分布式系统的核心：是一系列计算集群通过网络共同完成某一串连贯的任务</h5><h4 id="分布式计算为什么那么重要"><a href="#分布式计算为什么那么重要" class="headerlink" title="分布式计算为什么那么重要"></a>分布式计算为什么那么重要</h4><p>曾经，Google 构造过一个系统，这个系统要在TB级的数据上进行大量计算，比如创建所有网页内容的索引或分析整个网络的链接结构以便识别出最重要的页面或最权威的页面，正如大家知道的那样。</p><p>那时，整个网络甚至有，数十TB的数据，构建网络索引基本上等于跑遍所有的数据，这是相当耗时的。倘若在单台电脑上运算（计算量远远超出单台当时最好的单台计算机的计算能力），可能要花几周，几个月或几年，甚至更多。</p><p>Google当时是极其渴望能在数以千计的计算机上进行巨型数据计算以便计算可以快速完成。</p><p>因为相比于让一台计算机的计算能力翻倍，再购买一台计算机的成本要低的多得多。</p><p>我们希望构建一个这样一个系统：随着集群中的计算机越来越来越多，集群的计算能力越来越强。例如，原本在一个机子上运行10天能才能解决的问题，在一个由10个机子组成的集群中，我们希望他只花一天，并且随着集群的扩展，运算能力也能随之增强。</p><h5 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h5><p><a href="https://developer.aliyun.com/article/31829#slide-7">MapReduce译文</a></p><p><a href="http://labs.google.com/papers/mapreduce.html">MapReduce原文</a></p><p>MapReduce的个人总结</p><h3 id="容错问题"><a href="#容错问题" class="headerlink" title="容错问题"></a>容错问题</h3><p>一台计算机稳定的运行一年不是一件难事，但在数千台计算机组成的集群中，近乎每天都会发生个别计算机的故障（假设一台电脑平均运行1年会发生崩溃，也就是没365天崩溃一次，那在1000台电脑中，（1&#x2F;365）*1000&#x3D;2.74，每天近3台电脑发生崩溃）。因此，大型分布式系统，把一个很罕见的错误转变成常见的错误。</p><p>分布式系统中，总有一些机器会崩溃或者神秘地错误运行了。在一千台计算机的网络中，有许多的网络电缆，许多的网络交换机，要知道，现实中是会有人会踩着电缆的，或者某些交换机风扇损坏而导致不能正常工作。</p><p>故而，分布式系统应当对这些错误有着正确处理方式，来保证在个别主机出现问题时，仍然能够提供正常的服务。</p><h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><h5 id="虽然分布式系统有着高性能，高容错等优点，但要知道，这也意味着实现分布式系统是件极其复杂的工作，因此我们这设计一个系统时，一定要慎重考虑它是否能在单机系统上得到较好的解决，如果可以，进来避免采用分布式。"><a href="#虽然分布式系统有着高性能，高容错等优点，但要知道，这也意味着实现分布式系统是件极其复杂的工作，因此我们这设计一个系统时，一定要慎重考虑它是否能在单机系统上得到较好的解决，如果可以，进来避免采用分布式。" class="headerlink" title="虽然分布式系统有着高性能，高容错等优点，但要知道，这也意味着实现分布式系统是件极其复杂的工作，因此我们这设计一个系统时，一定要慎重考虑它是否能在单机系统上得到较好的解决，如果可以，进来避免采用分布式。"></a>虽然分布式系统有着高性能，高容错等优点，但要知道，这也意味着实现分布式系统是件极其复杂的工作，因此我们这设计一个系统时，一定要慎重考虑它是否能在单机系统上得到较好的解决，如果可以，进来避免采用分布式。</h5>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/08/6.824%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/08/6.824%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="6-824-分布式系统"><a href="#6-824-分布式系统" class="headerlink" title="6.824 分布式系统"></a>6.824 分布式系统</h2><h5 id="原视频"><a href="#原视频" class="headerlink" title="原视频"></a>原视频</h5><h5 id="翻译出处"><a href="#翻译出处" class="headerlink" title="翻译出处"></a>翻译出处</h5><p>让我们开始课程,本课程是 6.824 分布式系统</p><p>本节课我们从分布式系统的整体概要开始讲起</p><p>大家都知道本课程的核心是一系列计算集群通过网络共同完成某一串连贯的任务</p><p>因此，我们在本课程中重点介绍的一些案例包括:</p><ol><li>大型网站的储存系统</li><li>大规模数据集运算，如 MapReduce</li><li>点对点的文件共享</li></ol><p>这只是我们学习过程中的一些例子</p><p>我们同样会关注</p><ul><li><p>为何分布式计算之所以如此重要</p><p>是因为许多重要的基础设施都是在此基础上建立的</p><p>他们都需要多台计算机,或者说本质上是多台物理隔离的计算机共同完成自己的工作</p></li><li><p>以及为何人们要创建这种运算架构</p></li></ul><p>我会先介绍分布式系统,也是提醒大家:</p><p>在你设计一个系统时，或者面对一个你需要解决的问题时，你需要知道他是否可以在不需要分布式系统的单机上解决。如果可以那就应该用单机解决。</p><p>因为很多的工作都可以在一台计算机上完成，这通常比分布式系统简单很多。</p><p>在选择使用分布式系统解决问题前，你需要充分尝试别的思路，因为分布式系统会让问题解决变得复杂。</p><p>我们也会说是什么促使了人们通过计算集群来达到更高的计算性能。</p><p>以及思考他们是如何实现并行管理大量、CPU 大量内存、大量磁盘臂也在同时移动</p><p>以及为何要在计算集群中处理容错问题</p><p>比如两台计算机运行，完全相同的任务，以防在其中一台发生问题以及一些物理上的问题</p><p>比如你在用网银转账之类的操作，我们假设银行A在纽约有一台服务器，银行B在伦敦有一台服务器。</p><p>这就需要一种克服两个银行服务器之间物理距离的通信方式这是一个不可避免的空间问题最后人们为了解决一些安全问题。</p><p>比如有一些代码并不被信任但是你有需要和他进行交互，这些代码不会立刻做出坏事，或者说这些代码只是可能会有一些bug导致不被信任，你可能需要将代码分多处运行</p><p>在你的计算机上和我的计算机上都会运行两份代码需要通过某个狭义的网络协议通信。我们可能会担心这里的安全问题。我们把它分成更多的计算机，就可能出现孤立的问题这门课我们会一直讨论性能和容错剩下两点我们会通过对某些案例的研究来学习。下面我们来看这些分布式系统的问题。</p><p>因为系统中存在很多部分，这些部分又在并发执行正因为有多台计算机，所以才会遇到并发编程，以及各种复杂交互所带来的各种问题，我们还要考虑一些时序问题。</p><p>这让分布式系统这门课变得很难</p><p>另一个很难的问题是</p><p>你会有多个实例，再加上网络，所以会遇到一些意想不到的报错。</p><p>如果只有一台计算机，通常它只会正常工作，或者可能会崩溃，或者是电源有问题之类的工作或崩溃 这相对简单</p><p>分布式系统却不是这样，因为多台计算机中，可能会遇到一部分实例停止，导致的局部错误，但是其他部分依旧在正常运行，或者这些计算机都在正常运行但是网络断了或者不稳定。局部错误也是使这门课很难的原因之一。</p><p>最后一点很难的问题是：人们设计分布式系统的根本原因是为了获得更高的性能比如一千台计算机一千个磁盘臂达到的性能。但是实际上，一千台机器到底有几千台性能，是一个棘手的问题。这有很多难点</p><p>人们倍加小心地设计实际的系统 ，让你觉得，它的性能达到了你投入的预期，那么解决这些问题，就是本课的全部。</p><p>我想选择来上这门课，来解决这些问题是因为问题和解决方案在技术上都很有趣</p><p>有些很难的问题有着很漂亮的解决方案，但是有些问题就没有那么好的解决方案</p><p>关于应用的基础设施</p><p>即便课程中我们会分开说一些不同的应用别人 或者一些用户之类在这些基础设施上编写的应用但是我们在本课程中应该关注的是这些基础设施涉及许多储存 通信和计算问题.</p><p>我们会讨论包含所有这三个部分的基础设施但事实证明我们最关注的是储存部分这是一个定义明确并有用的抽象概念并且通常比较直白.</p><p>人们对于如何构建和使用储存系统</p><p>构建他们的系统时会用到类似远程过程调用（RPC）</p><p>RPC 的目标就是试图掩盖我们正在不可靠网络上通信的事实</p><p>另一个我们会看到的实现是线程这是一种编程技术让我们可以驾驭多核心计算机但是对于本课程而言 更重要的是线程提供了一种结构化的并发操作方式为的是简化程序员对这些并发操作的视角</p><p>我们知道在实现这个层次我们需要花费许多时间来思考并发控制但是你需要在实验里面对大多数这些问题</p><p>很多论文里都会提到的：性能</p><p>构建分布式系统的更高目标,是具有人们所谓的 可扩展的速度提升,是具有人们所谓的 可扩展的速度提升我们正在努力提高可扩展性我这里说的可扩展性 和可扩展的速度提升 指的是如果我用一台计算机解决了一些问题当我买第二台计算机去计算这个问题时只要一半的时间.或者说比如说是每分钟内可以解决两倍数量的问题.</p><p>一般来说一个网站有一个 HTTP 服务器让我们先写一些用户和很多浏览器他们在和一台web服务器通信比如是Python或者PHP写的服务以及访问一些数据库网站只有一两个用户的时候一台计算机就可以负担或者是一台跑web服务一台跑数据库但是有可能你的网站一夜之间火了起来你发现可能有一亿人注册你网站的账户。</p><p>你怎么去维护你的网站，一台机器承受一亿用户的流量不太可能，当然如果做了特殊的，劳动密集型优化除外但很显然你没有那个时间所以你要做的第一件事情就是购买更多的web服务器，然后把不同用户分到不同机器上，一些用户或者特定的用户去访问第一台服务器，另一半用户则去访问第二台。然而因为一些原因，比如你在建立reddit这种网站所有的用户都需要最终查看相同的数据你所有的web服务器都开始和数据库通信。当然你可以一直加web服务器，提高后端代码并行效率，但是如果你是在跑PHP或Python代码效率可能提高不了多少，因为单台服务器没有提高多少效率在数据库这里你也要加同样多的机器避免问题，但是不幸的是，这种可扩展性很少是无限的这个系统慢慢会变成，你现在有了10台 20台 甚至100台web服务器都在和同一个数据库通信突然数据库这里成了瓶颈再加更多的web服务器也无济于事。因为你有了很多的web服务器，瓶颈转移到了别的地方，我想是web服务器到数据库，限制了性能，实际上你不可避免地，要做一些架构设计，因为很少有，这么直接的从一台数据库读数据的例子，一台数据库你可以轻易排序但你需要重构把它分成多台数据库服务器</p><p>但这同样需要大量工作因为他很笨重但是很多人确实需要这样做</p><p>我们在本课程中会看到很多例子人们讨论的一个分布式系统是一个储存系统因为作者在运行大型网站并且单个服务器或者是储存服务器都用光了于是这个扩展的故事是我们希望可以这样简单的加钱买机器实现可扩展性但是这点很难实现于是这些设计工作其实会一直把这些想法推进下去</p><p>另一个重要的话题是容错如果你建立了一个单机系统其实很好的使用单台计算机可以让他保持运行很多年就像我办公室的服务器已经运行了很多年而不会崩溃一样，电脑是可靠的操作系统是可靠的我办公室的电源也是可靠的。所以一台计算机正常工作很长时间是并不少见的然而如果你建立了一个数千台计算机组成的集群，那么即使每台计算机可以与一千台计算机一起运行一年，这也意味着这一千台计算机中所以大型分布式系统中的一个大问题是我们把一个很罕见的错误转变成了一个在一千台的常见的错误，甚至在这种集群中一直在发生的错误总有一些机器会崩溃或者神秘地错误运行了或者卡顿 执行错误任务 之类。</p><p>再有一千台计算机的网络中有许多的网络电缆许多的网络交换机你要知道总有人会踩着电缆所以这是不可靠的或者网络电缆掉线了或者某些交换机风扇坏了然后他们过热就不工作了在你构建分布式系统的过程中各种地方总有一些小问题</p><p>因此这个这个分布式系统的扩容把一个几乎不必要考虑的小问题变成了一个持续不断的问题这意味着对错误而言正确回复 或者掩盖错误以及继续处理的能力必须要在架构设计时就建立因为错误总会发生</p><p>毕竟为应用开发者提供方便的抽象接口是我们真正要做的但是我们需要构建尽可能多的基础设施才可能向应用开发者隐藏和掩盖</p><p>这样每个应用开发者就不需要一个复杂的代码来处理各种各样的类型的错误比如说容错到底指什么</p><p>这会有一些不同的概念表述，这会有一些不同的概念表述，但你应该明确的知道尽管表述有很多</p><p>尽管表述有很多有一个共同的思想就是可用性，某些系统经过精心设计以便在某种特定类型的错误下当然特定类型不可能是所有类型系统可以正常运行</p><p>他们可以提供给你完整的服务他们可以提供给你完整的服务就像他们没有发生任何错误</p><p>某些系统的有这样一个可用的场景你建立了冗余的服务比如说有两个备份即便一个备份发生了问题即便一个备份发生了问题可能另一个服务器还能正常运行除非这两个都发生了错误我们不能在这个例子中给出可用性的承诺我们的可用性都是建立在特定错误类型上的这样才能继续正常服务</p><p>如果出现了超出范围的错误就不再可用了</p><p>另一种容错在除了可用性之外他们自身的可恢复性也是一方面这意味着如果出现问题他会停止工作他只是单纯的不响应请求了等到有人来进行修复后在修复完成后如果没有发生一些更糟糕的事情系统将可以继续正常运行</p><p>这比可用性要弱一些因为在出现故障的组件被修复之前他不会做任何事情但是这一切都建立在没有损失正确性的前提下所以这仍然是一个重要的要求所以这仍然是一个重要的要求你通常要在系统崩溃前做一些事情比如将最新日期存盘才能在恢复后取回来比如供电恢复之后对于一个高可用的系统在实际生活中我们为了让一个系统好用我们让系统保持可用直到一定量的错误发生如果有太多的错误发生这个系统就会停止工作或者停止对一切的响应但是一旦足够的问题被修复系统会继续工作所以一个好的高可用系统应该也是可恢复的</p><p>敏感的察觉发生了很多错误然后停止响应但是在之后依旧正确工作我们很喜欢这一点我们很喜欢这一点解决这种问题的多种方法解决这种问题的多种方法实际上在这一部分中最重要的工具是</p><p>非易失性存储一些类似于电源崩溃故障即便是整栋楼的电源故障我们可以用非易失性存储像硬盘 闪存 SSD 之类的储存工具，像硬盘 闪存 SSD 之类的储存工具或者关于系统状态的日志在备用电源恢复或者故障修好了我们得到通知可以去</p><p>读取最新的硬盘状态并且继续从那里继续操作</p><p>（板书）非易失性存储于是出现了许多非易失性存储的管理工具，因为非易失性存储更新起来很昂贵，因此构建高性能容错系统非常繁琐</p><p>所以一个聪明的方法是避免写入非易失性存储</p><p>这在过去很常用即便在今天 写入非易失性存储也需要移动磁盘臂等待磁盘盘面旋转这两个过程都很缓慢现在3GHz的微处理器即便已经在闪存读写上好了很多依旧会遇到很多性能不够的情况</p><p>我们拥有的另一个重要的容错的工具是复制</p><p>复制的管理对你们可能有些棘手任何一个复制系统中都有一个非常关键的问题比如我们有两台本应该有着完全相同的副本的系统这个关键的问题就是这两个副本总会意外的偏离同步的状态 不再正确实际上对于任何一个设计我们都能看到这种</p><p>通过使用复制实现的容错实验2就是一个通过管理管理复制实现的容错你们会看到这非常复杂</p><p>最后一个话题 也是一个跨领域的话题是一致性</p><p>例如我们正在构建分布式存储系统例如我们正在构建分布式存储系统假设这是一个键&#x2F;值服务(KV服务)</p><p>它只支持两种操作一个是「放入」(Put)提供一个key和一个value放入</p><p>系统背后可能是一个通过一个大型的表之类</p><p>实现了这种操作另一个是「取出」(Get)你用客户端发送一个key储存服务找到这个key对应的value</p><p>除了KV系统之外我很难找到把别的例子作为分布式系统的例子这是一个还不错的例子这个例子也很实用这可以算是一种简单版本的储存系统</p><p>当然如果你是一位应用程序员</p><p>处于性能和容错两方面考虑我们通常有多个数据副本</p><p>所以在一个非分布式系统中我们只有一台服务器一张表他们通常（虽然也不总是）是没有相对而言没有歧义的</p><p>当你做 Put Get 的时候一般就是正确的</p><p>你知道Put操作就是更新这个表Get操作就是从当前版本的表里取回值</p><p>但是在分布式系统中数据可能有超过一个副本</p><p>可能是因为复制或缓存的原因</p><p>于是有了很多个不同版本的KV对出现</p><p>如果其中有一个客户</p><p>Put进了一个新的副本</p><p>在服务器就有了两个副本</p><p>（板书）他们都有KV表</p><p>（板书）他们都有KV表</p><p>比如两个表1对应的值是20</p><p>这里有一个客户端</p><p>他希望更新把1对应的值改成了21</p><p>比如这可能是一个计数器于是他发送一个Put</p><p>Key为1 Value为21他发送给了第一台服务器</p><p>他需要同步每一个副本</p><p>就在他正准备给第二台服务器发送同样的请求时</p><p>这个客户端崩溃了可能是电源故障</p><p>或者操作系统bug之类现在留下了一个不太好的状态我们发送的Put值更新了两个副本中一个的状态</p><p>一个是21 另一个仍是20</p><p>现在有人来尝试用一个Get来读取</p><p>他们想要得到Key为1对应的值他们可能得到了21或者20</p><p>这取决于他们的请求发送到了哪个服务器</p><p>即便始终把第一台服务器放在首位</p><p>我们构建容错系统时实际规则应该是你先去请求第一台服务器遇到某些情况再请求下面这台</p><p>所以不管怎么说 你有总有一天有风险遇到陈旧的数据副本很有可能的是许多的Get都得到了21</p><p>但是比如下周突然有一个Get请求到了一周前的旧数据请求到了一周前的旧数据</p><p>所以我们需要实际写下关于Put和Get操作的一些规则就像在这种危险的复制中</p><p>关于一致性的不同定义有很多许多</p><p>听起来相对直白：Put一定要是一个完整的Put</p><p>这就是所谓的强一致性</p><p>相对弱的一致性也很有用比如说我们不保证任何类似Get的操作可以看到最新的Put写入的值</p><p>对于弱一致性系统他们不会做任何保证这些保证可能是某个人做了Put，你可能看不到这个Put的结果 而是旧的值</p><p>甚至可能在一个无限的时间里都是这样</p><p>人们之所以对弱一致性感兴趣因为强一致性虽然可以让我看到的就是保证是最新的值</p><p>但是这个实现可能很昂贵因为这意味着总有部分需要做很多的通信来完成某一种强一致性概念的实现所以为了尽可能地避免通信人们会建立一个弱一致性系统它实际上允许读取这个旧的值当然为了让弱一致性更有用，</p><p>如果我们把副本用于容错我们实际上希望他们可以有着不同的故障概率也就是不相关的故障</p><p>把所有的副本放在同一个机房的，因为如果有人绊倒了我们的两个副本都会完蛋</p><p>为了使副本尽可能独立且容错</p><p>以获得良好的容错能力人们希望将不同的副本尽可能地分开远放例如放在不同的城市或大陆的相对的两侧</p><p>这样，能摧毁一个数据中心的地震就极不可能也摧毁另一个作为备份的数据中心</p><p>如大家所知，我们希望能够做到这一点，如果你这样做那么另一个副本是在数千英里开外</p><p>按光传播的速度来算，它可能会耗费几毫秒或几十毫秒与横跨洲际的数据中心进行通信只为更新数据的另一个副本这使得通信需要强一致性和高一致性，极可能非常耗时</p><p>都在研究如何构建，弱一致性保证，那样他们</p><p>对应用程序才真正有用，以及如何，利用它们来</p><p>实质性获得高性能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅的做一个班长</title>
    <link href="/2022/12/10/%E7%94%A8pandas%E5%A4%84%E7%90%86%E8%A1%A8%E6%A0%BC/"/>
    <url>/2022/12/10/%E7%94%A8pandas%E5%A4%84%E7%90%86%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="用pandas处理表格"><a href="#用pandas处理表格" class="headerlink" title="用pandas处理表格"></a>用pandas处理表格</h2><p>作为一名班干，经常要帮助辅导员从同学们手上收集各种表格，还有从全学院或者全校的学生信息出挑出本班同学的信息让同学们核对，故经常出现一下情况：</p><ul><li>收集了大部分同学时，有小部分同学没有收集，筛查比较麻烦</li><li>在从上万条信息中筛选出本班同学信息，在同学们的信息填写完整时，还是比较容易用Excel筛选出来，但总有小部分同学信息不完善，又会漏掉。</li><li>需要抽少部分同学去完成某项任务</li></ul><p>python中的pandas可以很方便的帮助我们完成表格数据的对比。</p><p>值得注意的是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pandas.read_excel(filename, sheet_name=<span class="hljs-number">0</span>)<span class="hljs-comment">#慢</span><br><br>pandas.read_csv(filename, encoding=<span class="hljs-string">&quot;gbk&quot;</span>)<span class="hljs-comment">#快</span><br></code></pre></td></tr></table></figure><p>read_csv的执行效率很快，但是生成的CSV文件在手机不能直接预览，即使后面再用Excel修改文件类型后仍有问题，而大部分学生收到通知都是在手机，故很不方便。</p><p>一开始用一下代码来检查文件与学生信息的包含关系是，总是要执行<code>pandas.read_excel(filename, sheet_name=0)</code>，很慢,比CSV的打开慢10倍不止。</p><p>后来干脆弃用这个函数，直接把for循环提出来写到调用的地方，这样就只用打开一次文件了，效率大大增加了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">contain</span>(<span class="hljs-params">filename, index, name</span>):<br>    file = pandas.read_excel(filename, sheet_name=<span class="hljs-number">0</span>).values<br>    <span class="hljs-comment"># file = pandas.read_csv(filename, encoding=&quot;gbk&quot;).values</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file)):<br>        <span class="hljs-keyword">if</span> file[i][index] == name:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>后面附上代码，抽签的也有，喜欢的班干可以拿去修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是一个示例 Python 脚本。</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pandas<br><span class="hljs-keyword">import</span> csv<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">contain</span>(<span class="hljs-params">filename, index, name</span>):<br>    file = pandas.read_excel(filename, sheet_name=<span class="hljs-number">0</span>).values<br>    <span class="hljs-comment"># file = pandas.read_csv(filename, encoding=&quot;gbk&quot;).values</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file)):<br>        <span class="hljs-keyword">if</span> file[i][index] == name:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># index为名字所在列的下标</span><br><span class="hljs-comment"># 文件1和文件2中都有的</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">whoFinish</span>(<span class="hljs-params">filename1, index1, filename2, index2</span>):<br>    file1 = pandas.read_excel(filename1, sheet_name=<span class="hljs-number">0</span>).values<br>    file2 = pandas.read_excel(filename2, sheet_name=<span class="hljs-number">0</span>).values<br>    data = []<br>    filename = time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d-%H-%M-%S&#x27;</span>)<br>    filename = filename + <span class="hljs-string">&quot;.xlsx&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file1)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file2)):<br>            <span class="hljs-built_in">print</span>(file1[i][index1])<br>            <span class="hljs-keyword">if</span> file2[j][index2] == file1[i][index1]:<br>                data.append(file1[i])<br>    data = pandas.DataFrame(data)<br>    data.to_excel(filename, index=<span class="hljs-literal">False</span>)<br><br><span class="hljs-comment">#文件1中有，文件2中没有</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">whoNotFinish</span>(<span class="hljs-params">filename1, index1, filename2, index2</span>):<br>    file1 = pandas.read_excel(filename1, sheet_name=<span class="hljs-number">0</span>).values<br>    file2 = pandas.read_excel(filename2, sheet_name=<span class="hljs-number">0</span>).values<br>    data = []<br>    message = <span class="hljs-string">&quot;请上同学尽快完成&quot;</span><br>    filename = time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d-%H-%M-%S&#x27;</span>)<br>    filename = filename + <span class="hljs-string">&quot;.xlsx&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file1)):<br>        flag = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file2)):<br>            <span class="hljs-keyword">if</span> file2[j][index2] == file1[i][index1]:<br>                flag = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>:<br>            data.append(file1[i])<br>            message = <span class="hljs-string">&quot;@&quot;</span> + file1[i][index1] + <span class="hljs-string">&quot;,\n&quot;</span> + message<br>    data = pandas.DataFrame(data)<br>    <span class="hljs-comment"># data.to_excel(filename, index=False)</span><br>    <span class="hljs-built_in">print</span>(message)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">list1, str1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(list1)):<br>        <span class="hljs-keyword">if</span> str1 == list1[i]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mixlot</span>(<span class="hljs-params">stuNumber</span>):<br>    data = pandas.read_csv(<span class="hljs-string">&quot;抽签.csv&quot;</span>, encoding=<span class="hljs-string">&quot;gbk&quot;</span>)<br>    stus = data.values<br>    lucky = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(lucky) &lt; stuNumber:<br>        stu = stus[random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(stus) - <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">if</span> check(lucky, stu[<span class="hljs-number">0</span>]):<br>            lucky.append(stu[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> lucky<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lot</span>(<span class="hljs-params">nboy, ngirl, </span>):<br>    <span class="hljs-comment"># 在下面的代码行中使用断点来调试脚本。</span><br>    data = pandas.read_csv(<span class="hljs-string">&quot;抽签.csv&quot;</span>, encoding=<span class="hljs-string">&quot;gbk&quot;</span>)<br>    stus = data.values<br>    girls = []<br>    boys = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(data)):<br>        <span class="hljs-keyword">if</span> stus[i][<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;女&#x27;</span>:<br>            girls.append(stus[i][<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">else</span>:<br>            boys.append((stus[i][<span class="hljs-number">0</span>]))<br>    <span class="hljs-comment"># print(len(stus))</span><br>    <span class="hljs-comment"># print(len(boys))</span><br>    <span class="hljs-comment"># print(len(girls))</span><br>    lucky_boys = []<br>    lucky_girls = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(lucky_boys) &lt; nboy:<br>        boy = boys[random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(boys) - <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">if</span> check(lucky_boys, boy):<br>            lucky_boys.append(boy)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(lucky_girls) &lt; ngirl:<br>        girl = girls[random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(girls) - <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">if</span> check(lucky_girls, girl):<br>            lucky_girls.append(girl)<br>    <span class="hljs-keyword">return</span> lucky_girls, lucky_boys<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># print(&quot;抽签将在2分钟后完成&quot;)</span><br>    <span class="hljs-comment"># print(&quot;现在的时间是：&quot;)</span><br>    <span class="hljs-comment"># print(time.ctime(time.time()))</span><br>    <span class="hljs-comment"># time.sleep(0)</span><br>    <span class="hljs-comment"># print(&quot;抽签结束，结果如下&quot;)</span><br>    <span class="hljs-comment"># print(&quot;现在的时间是：&quot;)</span><br>    <span class="hljs-comment"># print(time.ctime(time.time()))</span><br>    <span class="hljs-comment"># print(lot(1,0))</span><br>    <span class="hljs-comment"># print(mixlot(2))</span><br><br>     <span class="hljs-comment">#whoFinish(&quot;221208秋季学期老生形策课线上课成绩.xlsx&quot;,2,&quot;抽签.xlsx&quot;,0)</span><br>     whoNotFinish(<span class="hljs-string">&quot;抽签.xlsx&quot;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&quot;2020级班级情况表.xlsx&quot;</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO的面向接口</title>
    <link href="/2022/10/31/GO%E7%9A%84%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/10/31/GO%E7%9A%84%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GO的面向对象</title>
    <link href="/2022/10/31/GO%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/10/31/GO%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/20/hello-world/"/>
    <url>/2022/10/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go的单元测试</title>
    <link href="/2022/10/20/%E5%85%B3%E4%BA%8EGO%E7%9A%84%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/10/20/%E5%85%B3%E4%BA%8EGO%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="单元测试的意义"><a href="#单元测试的意义" class="headerlink" title="单元测试的意义"></a>单元测试的意义</h3><p>软件系统是由许多个单元构成的，这些单元可能是对象、类、 函数，或者是一个更大的单元——组件或者模块。软件系统的整体质量就是由各个单元的质量保证，通过充分的单元测试，发现并修正单元中的问题，从而为系统的质量打下基础。</p><h3 id="单元测试的工具"><a href="#单元测试的工具" class="headerlink" title="单元测试的工具"></a>单元测试的工具</h3><p>单元测试一般针对程序代码进行测试，因此测试工具和特定的编程语言密切相关。典型的就是<code>xxxUnit</code>工具家族</p><p>例如：</p><ul><li><code>Junit</code> for JAVA</li><li><code>CppUnit</code> for C++</li><li><code>NUnit</code> for C#(.NET)</li></ul><h6 id="而GO语言则是通过标准库testing进行单元测试的"><a href="#而GO语言则是通过标准库testing进行单元测试的" class="headerlink" title="而GO语言则是通过标准库testing进行单元测试的"></a>而GO语言则是通过标准库<code>testing</code>进行单元测试的</h6><h3 id="GO的单元测试"><a href="#GO的单元测试" class="headerlink" title="GO的单元测试"></a>GO的单元测试</h3><p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 <code>_test.go</code> 结尾。比如，当前 package 有 <code>calc.go</code> 一个文件，我们想测试 该文件里的单元（通常是函数），那么应该新建 <code>calc_test.go</code> 作为测试文件（<code>GoLand</code>中右击需要测试的文件，选择<code>go to</code>下的<code>testing</code>即可生成）。</p><p>在测试文件内有三种函数。</p><table><thead><tr><th><strong>类型</strong></th><th><strong>格式</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>测试函数</td><td>函数名前缀为Test</td><td>测试程序的一些逻辑行为是否正确</td></tr><tr><td>基准函数</td><td>函数名前缀为Benchmark</td><td>测试函数的性能</td></tr><tr><td>示例函数</td><td>函数名前缀为Example</td><td>为文档提供示例文档</td></tr></tbody></table><h6 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h6><p>在<code>GoLand</code>中右击需要测试的函数，选择<code>go to</code>下的<code>testing</code>即可生成对应的测试函数（不同控制状态下的函数生成对应的测试函数名不同，<code>Add</code>会生成<code>TestAdd</code>而<code>add</code>则生成<code>Test_add</code>，不过均以Test作为前缀）</p><p>Add函数如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> ex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的对应的测试函数如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> ex<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdd</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">//参数结构体</span><br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int</span><br>b <span class="hljs-type">int</span><br>&#125;<br>    <span class="hljs-comment">//测试结构体，每一例测试包含了名字和参数和期望输出</span><br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span>  <br>want <span class="hljs-type">int</span><br>        args args<br>&#125;&#123;<br>        <span class="hljs-comment">// (在此处添加测试样例)<span class="hljs-doctag">TODO:</span> Add test cases.</span><br>&#125;<br>    <span class="hljs-comment">//遍历测试样例，分别执行</span><br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>            <span class="hljs-comment">//在测试样例的参数传进去，返回的结果与期望比较，不同的话调用Errorf输出</span><br><span class="hljs-keyword">if</span> got := Add(tt.args.a, tt.args.b); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;Add() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，测试函数的参数只有一个 <code>t testing.t</code>,他用于报告测试失败和附加的日志信息。 <code>testing.T</code>的拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Error(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Errorf(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Fail()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> FailNow()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Failed() <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Fatal(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Fatalf(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Log(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Logf(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Name() <span class="hljs-type">string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Parallel()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Run(name <span class="hljs-type">string</span>, f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span>) <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Skip(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> SkipNow()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Skipf(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Skipped() <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p>查看测试覆盖率：在命令行终端执行<code>go test -cover -coverprofile=d</code>后，会在当前目录下生成一个文件d</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -cover -coverprofile=d<br>--- FAIL: TestAdd (0.00s)                <br>    --- FAIL: TestAdd/1+2 (0.00s)        <br>        add_test.go:20: Add() = 3, want 4<br>--- FAIL: TestSolution (0.00s)                  <br>    非空子序列_test.go:31: expected:&#123;3&#125;, got:&#123;4&#125;<br>FAIL                                            <br>coverage: 100.0% of statements                  <br><span class="hljs-built_in">exit</span> status 1                         <br>FAIL    awesomeProject/ex       0.209s<br><br></code></pre></td></tr></table></figure><p>使用 <code>go tool cover -html=d </code>，即可在浏览器中打开查看详细情况。</p><p><img src="/../image/image-20221018175049523.png"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>本文只是简单的讲了如何在Go中进行单元测，同步学校的软件测试课程（课上讲的是JUnit，自己跟倾向go方向），后面会随着课程的推进不断完善，例子和操作的是一些最基础的，想要写出高质量的代码，就不得不编写更多刁钻的测试用例和测试代码，来不断测试并完善自己的代码。</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p><a href="https://www.liwenzhou.com/posts/Go/unit-test/#autoid-2-4-0">李文周的博客</a></p><p><a href="https://geektutu.com/post/quick-go-test.html">极客兔兔</a></p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用git删除GitHub上的项目内的文件</title>
    <link href="/2022/09/30/%E4%BD%BF%E7%94%A8git%E5%88%A0%E9%99%A4%E9%A1%B9%E7%9B%AE%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <url>/2022/09/30/%E4%BD%BF%E7%94%A8git%E5%88%A0%E9%99%A4%E9%A1%B9%E7%9B%AE%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="使用git删除GitHub上的项目内的文件"><a href="#使用git删除GitHub上的项目内的文件" class="headerlink" title="使用git删除GitHub上的项目内的文件"></a>使用git删除GitHub上的项目内的文件</h4><h5 id="首先把项目拉倒克隆到本地"><a href="#首先把项目拉倒克隆到本地" class="headerlink" title="首先把项目拉倒克隆到本地:"></a>首先把项目拉倒克隆到本地:</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/linyegui/linyegui.github.io.git<br></code></pre></td></tr></table></figure><h5 id="进入项目文件的分支里运行git-bash"><a href="#进入项目文件的分支里运行git-bash" class="headerlink" title="进入项目文件的分支里运行git bash"></a>进入项目文件的分支里运行git bash</h5><p>使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.email <span class="hljs-string">&quot;youremail&quot;</span><br>$ git config --global user.name <span class="hljs-string">&quot;emailname&quot;</span><br>$ <span class="hljs-built_in">dir</span><br>$ git <span class="hljs-built_in">rm</span> -r --cached text<br>$ git commit -m <span class="hljs-string">&#x27;remove text&#x27;</span><br>$ git push -u origin main     //提交到远程仓库<br><br></code></pre></td></tr></table></figure><p>提交很有可能超时，必要时记得科学上网</p><h5 id="也可使用cd命令进入："><a href="#也可使用cd命令进入：" class="headerlink" title="也可使用cd命令进入："></a>也可使用cd命令进入：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> filename //进入当前目录下名为filename的子目录<br>$ <span class="hljs-built_in">cd</span> ..       //回到当前目录的父级目录<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
