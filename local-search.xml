<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/06/01/Timer%E5%92%8Ctime.sleep/"/>
    <url>/2023/06/01/Timer%E5%92%8Ctime.sleep/</url>
    
    <content type="html"><![CDATA[<p>Timer和time.sleep</p><p>您可能指的是在等待计时器的通道时，程序仍然被阻塞了，因为它等待了5秒钟。这是正确的，因为在等待计时器的通道时，程序确实被阻塞了。但是，与使用<code>time.Sleep()</code>函数不同的是，使用计时器的通道可以让我们在等待期间执行其他任务。</p><p>在示例代码中，我们在等待计时器的通道时，打印了一条信息，以便观察goroutine的行为。虽然在等待计时器的通道时，程序确实被阻塞了5秒钟，但是我们在等待期间仍然可以执行其他任务，例如打印一些信息。这使得计时器的通道比使用<code>time.Sleep()</code>函数更加灵活和高效。</p><p>因此，虽然在等待计时器的通道时，程序仍然被阻塞了，但是我们可以在等待期间执行其他任务，从而提高程序的响应性和效率。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Reflect中的一个小细节</title>
    <link href="/2023/05/29/Reflect%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <url>/2023/05/29/Reflect%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h3 id="Reflect中的小细节"><a href="#Reflect中的小细节" class="headerlink" title="Reflect中的小细节"></a>Reflect中的小细节</h3><p>使用反射实现一次调用有两种方式，</p><p>一种是<code>reflect.ValueOf(rcvr).Method(0).Call([]reflect.Value&#123;&#125;)</code></p><p>另一种是<code>reflect.TypeOf(rcvr).Method(0).Func.Call([]reflect.Value&#123;reflect.ValueOf(rcvr)&#125;)</code></p><p>两者在使用Call()进行调用时，需要的参数不同，通过第二种方式需要额外传递该方法的接受者的reflect.ValueOf</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Test <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Test)</span></span> Test1() &#123;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">VCall</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>reflect.ValueOf(rcvr).Method(<span class="hljs-number">0</span>).Call([]reflect.Value&#123;&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MCall</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><br>reflect.TypeOf(rcvr).Method(<span class="hljs-number">0</span>).Func.Call([]reflect.Value&#123;reflect.ValueOf(rcvr)&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过基准测试对他们的性能做个基本的了解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-keyword">var</span> t1 Test<br><span class="hljs-keyword">var</span> t2 Test<br><span class="hljs-keyword">var</span> t3 Test<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMCall</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>      MCall(t1)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkVCall</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>      VCall(t2)<br>   &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkTest_Test1</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>      t3.Test1()<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现反射的实现一次调用的性能是极差的，如果是出于性能考虑，尽量不用反射。如果是为了追求灵活性的话，可以考虑直接调用的方式：reflect.TypeOf(rcvr).Method(0).Func.Call([]reflect.Value{reflect.ValueOf(rcvr)})</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>BenchmarkMCall</td><td>3155775</td><td>370.4 ns&#x2F;op</td></tr><tr><td>BenchmarkVCall</td><td>6557368</td><td>176.6 ns&#x2F;op</td></tr><tr><td>BenchmarkTest_Test1</td><td>1000000000</td><td>0.2450 ns&#x2F;op</td></tr></tbody></table><p>在RPC框架中，应该使用直接调用的方式。因为RPC框架通常是在网络上进行远程调用，需要将调用的参数和返回值进行序列化和反序列化，增加了一定的开销。如果再使用动态调用的方式，会进一步增加开销，导致性能下降。</p><p>使用直接调用的方式可以在编译时确定方法的调用方式和参数，减少了序列化和反序列化的开销，提高了性能。同时，直接调用的代码可读性更好，可以方便地进行维护和调试。</p><p>RPC框架的实现方式并不是唯一的，也可以通过手动编写代码来实现RPC框架，这样可以减少反射机制的使用，提高RPC框架的性能。同时，手动编写代码实现RPC框架的可读性更好，方便维护和调试。</p><p>因此，RPC框架是否使用反射实现，应该根据具体的场景和需求来进行选择。如果追求灵活性和通用性，可以使用反射实现；如果追求性能和可读性，可以手动编写代码实现RPC框架。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>Reflect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个基于TCP的RPC工作流程</title>
    <link href="/2023/05/29/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8ETCP%E7%9A%84RPC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/05/29/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8ETCP%E7%9A%84RPC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一个基于TCP的RPC工作流程"><a href="#一个基于TCP的RPC工作流程" class="headerlink" title="一个基于TCP的RPC工作流程"></a>一个基于TCP的RPC工作流程</h2><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>客户端要想调用服务端的一个函数，需要把自己调用的函数名参数告诉服务端，服务端拿到函数名和参数后，就可以执行对应的函数并将结果返回。通常客户端和服务端之间通过建立一个TCP连接来传递调用信息和应答。</p><h4 id="1-监听指定端口来接收客户端发起的连接"><a href="#1-监听指定端口来接收客户端发起的连接" class="headerlink" title="1.监听指定端口来接收客户端发起的连接"></a>1.监听指定端口来接收客户端发起的连接</h4><p><img src="/../img/image-20230527000045492.png" alt="image-20230527000045492"></p><h4 id="2-客户端发起连接"><a href="#2-客户端发起连接" class="headerlink" title="2.客户端发起连接"></a>2.客户端发起连接</h4><p><img src="/../img/image-20230527145034427.png" alt="image-20230527145034427"></p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><h5 id="客户端和服务端如何正确的从基于字节流的TCP连接上解析出对方发来的信息？"><a href="#客户端和服务端如何正确的从基于字节流的TCP连接上解析出对方发来的信息？" class="headerlink" title="客户端和服务端如何正确的从基于字节流的TCP连接上解析出对方发来的信息？"></a>客户端和服务端如何正确的从基于字节流的TCP连接上解析出对方发来的信息？</h5><p>这就需要到消息的序列化和反序列化了，序列化和反序列化是将数据结构转换为字节流或将字节流转换为数据结构的过程。常见的序列化和反序列化工具有以下几种：</p><ol><li>JSON：一种轻量级的数据交换格式，易于人阅读和编写，支持多种编程语言，如 Java、Python、JavaScript </li><li>XML：一种标记语言，可用于表示各种数据结构，如文本、数字、日期、布尔值、数组、对象等。</li><li>Protobuf：Google 开发的一种高效的序列化和反序列化工具，支持多种编程语言，如 Java、C++、Python </li><li>Thrift：Facebook 开发的一种高效的跨语言序列化和反序列化工具，支持多种编程语言，</li></ol><p><img src="/../img/image-20230527152236837.png" alt="image-20230527152236837">如果客户端和服务端使用的不是同一种序列化和反序列化工具，通常会导致解析错误，所以支持协商好消息的编解码方式的RPC框架中，需要事先协商好消息的编解码方式，可以是双发约以定固定字段为序列化方式，也可以在建立连接后，双发通过一个默认的编解码方式协商好序列化方式如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">|<span class="hljs-type">Option</span>&#123;MagicNumber: xxx, CodecType: xxx&#125; | <span class="hljs-type">Header</span>&#123;ServiceMethod ...&#125; | <span class="hljs-type">Body</span> interface&#123;&#125;|<br><span class="hljs-type">|&lt;------      固定 JSON</span> 编码      ------&gt;   | <span class="hljs-type">&lt;-------   编码方式由 CodeType</span> 决定   -------&gt;|<span class="hljs-type"></span><br></code></pre></td></tr></table></figure><p>在连接建立后，客户端会发送率先发送一个Option,这一段数据的序列化方式是早就协商好了的，所以服务端以最先协商序列化方式读取就好了。</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>想要从字节流中解析出我们想要的数据，除了需要双方的序列化和反序列化方式一样之外，还需要有一个能够接收数据的结构体。服务端是如何选择一个结构体去接收数据呢？</p><p>Header的内容是确定的，服务端每次都先用一个Header实例去接收客户端发来的一个请求头信息，而服务端便是凭借请求头里的ServiceMethod，确定用什么去接收数据的。具体的做法是：</p><p>1.服务端维护着一个serviceMap sync.Map，其中以服务名为键，以服务实例为值。</p><p>2.每个服务实例里维护着一个map,该map存储着这个服务下的所有方法Methdo的信息。</p><p>3.每个Method记录着以下信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> methodType <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//方法本身</span><br>method reflect.Method<br><span class="hljs-comment">//方法的第一个参数的类型</span><br>ArgType reflect.Type<br><span class="hljs-comment">//方法的第二个参数的的类型</span><br>ReplyType reflect.Type<br><br>&#125;<br></code></pre></td></tr></table></figure><p>所以通过ServiceMethod我们可以找到一个服务下的一个Methdo的信息的信息methodType，再根据methodType中的ArgType动态创建实例，有了实例，便可以接收到客户端的数据啦！</p><p>接收数据后就可以交给method reflect.Method处理啦，具体通过method.Func.call()调用了，返回值也是根据ReplyType动态创建实例接收。在进行序列化返回给客户端。</p><p>服务注册，就是创建和维护这连个map的过程。</p><p>以上便是一次最简单的远程调用过程。但一个RPC框架所提供的远不止这些。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/05/20/WebSocket%20%E8%BF%98%E6%98%AF%20AJAX/"/>
    <url>/2023/05/20/WebSocket%20%E8%BF%98%E6%98%AF%20AJAX/</url>
    
    <content type="html"><![CDATA[<p>一个RPC框架的主要功能通常包括以下几个方面：</p><ol><li><p>定义IDL语言：提供一种IDL语言，用于描述远程接口的名称、参数、返回值等信息，以便客户端和服务器之间进行通信。</p><p>以下是一个使用Google Protocol Buffers IDL语言描述的示例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> example;<br><span class="hljs-comment">//描述了一个名为Person的数据结构，包含三个字段：name、age和address</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int32</span> age = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">string</span> address = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">HelloService</span> &#123;<br>  <span class="hljs-comment">//描述了一个名为HelloService的服务,以Person为参数，以string为返回值</span><br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (Person) <span class="hljs-keyword">returns</span> (string)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>序列化和反序列化：将IDL语言描述的数据结构序列化成二进制格式，以便在网络上进行传输，同时也支持将二进制格式反序列化成数据结构。</p></li><li><p>传输协议：提供一种传输协议，用于在客户端和服务器之间传输数据。常用的传输协议包括TCP、UDP、HTTP等。</p></li><li><p>服务注册和发现：提供一种服务注册和发现机制，使得客户端可以发现可用的服务器，以便调用远程接口。</p></li><li><p>负载均衡：提供一种负载均衡机制，使得客户端可以将请求均匀地分配给多个服务器，以提高系统的可用性和性能。</p></li><li><p>错误处理：提供一种错误处理机制，使得客户端和服务器可以处理各种错误情况，例如网络故障、超时等。</p></li><li><p>安全性和认证：提供一种安全性和认证机制，使得客户端和服务器之间的通信是安全可靠的，可以防止数据被篡改或者窃取。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL连接错误：Error 1045</title>
    <link href="/2023/05/18/MySQL%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%EF%BC%9AError%201045%20Access%20denied%20for%20user%20&#39;username&#39;@&#39;host&#39;%20(using%20password%20YES)/"/>
    <url>/2023/05/18/MySQL%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%EF%BC%9AError%201045%20Access%20denied%20for%20user%20&#39;username&#39;@&#39;host&#39;%20(using%20password%20YES)/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL连接错误：Error-1045-Access-denied-for-user-‘username‘-’host’-using-password-YES"><a href="#MySQL连接错误：Error-1045-Access-denied-for-user-‘username‘-’host’-using-password-YES" class="headerlink" title="MySQL连接错误：Error 1045: Access denied for user ‘username‘@’host’ (using password: YES)"></a>MySQL连接错误：Error 1045: Access denied for user ‘username‘@’host’ (using password: YES)</h2><h5 id="最近在配置云数据库时，总是报这个错误。网上给出的答案是连接数据库时用户名或密码不正确导致的。可能的原因包括："><a href="#最近在配置云数据库时，总是报这个错误。网上给出的答案是连接数据库时用户名或密码不正确导致的。可能的原因包括：" class="headerlink" title="最近在配置云数据库时，总是报这个错误。网上给出的答案是连接数据库时用户名或密码不正确导致的。可能的原因包括："></a>最近在配置云数据库时，总是报这个错误。网上给出的答案是连接数据库时用户名或密码不正确导致的。可能的原因包括：</h5><ol><li><p>用户名或密码输入错误</p></li><li><p>用户名或密码被限制访问</p></li><li><p>数据库服务未启动</p><p>在自己电脑上使用Navicat,通过相同的账号密码连接成功了，以上问题一下就排查掉了</p></li><li><p>MySQL驱动程序未导入或版本不匹配</p><p>使用以下代码更新后依然报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/go-sql-driver/mysql<br></code></pre></td></tr></table></figure></li></ol><p>OK，虽然我没有通过以上办法解决问题，但通过上面的步骤应该能帮助你解决这个问题。</p><h5 id="梦回大一"><a href="#梦回大一" class="headerlink" title="梦回大一"></a>梦回大一</h5><p>我是怎么解决的呢？一开始是通过配置文件<code>.ini</code>来配置数据库的，使用的是<code>ini.MapTo()</code>来映射配置。后来直接在代码中写进配置，发现连通了。这说明配置文件中的密码没问题，会不会是加载配置文件除了问题呢？于是乎把加载到的配置参数打印出来，果不其然，密码错了（密码以<code>#</code>结尾，而打印出来的密码不带有<code>#</code>）。原因是：</p><blockquote><p>在使用ini.MapTo()函数将配置文件中的内容映射到结构体时，如果配置文件中的某些键名或键值以“#”开头，可能会导致MapTo()函数无法正确读取这些键名或键值。这是因为“#”在INI文件中被用作注释符号，表示后面的内容都是注释，不应该被解析。</p></blockquote><p>配置文件在Goland打开的检查的，没高亮提醒（期间提示我安装插件，我忽略了，QAQ），真倒霉。这不禁让我想起当年刚学C语言时，因为main函数敲成mian导致找bug找了一整天，也是因为粗心。不过不得不说，编辑器确实也是给代码质量提供了不少保障。</p><p>在使用ini.MapTo()函数将配置文件中的内容映射到结构体时，如果配置文件中的某些键名或键值以“#”开头，可能会导致MapTo()函数无法正确读取这些键名或键值。这是因为“#”在INI文件中被用作注释符号，表示后面的内容都是注释，不应该被解析。</p><p>要解决这个问题，可以尝试以下方法：</p><ol><li>修改配置文件</li></ol><p>可以将配置文件中以“#”开头的键名或键值改为其他字符。例如，将“#key &#x3D; value”改为“_key &#x3D; value”。</p><ol><li>使用其他INI解析库</li></ol><p>如果配置文件中的键名或键值不能修改，可以尝试使用其他INI解析库，例如go-ini或ini.v1。这些库可能支持更多的配置文件格式和特性，可以更好地解析包含“#”字符的键名或键值。</p><ol><li>手动解析配置文件</li></ol><p>如果以上方法都无法解决问题，可以尝试手动解析配置文件。可以使用bufio.Scanner读取文件内容，然后使用strings.Split()函数将每一行分割为键名和键值，再将它们映射到结构体中。手动解析虽然比较麻烦，但可以更精确地控制解析过程，并且可以处理更复杂的配置文件格式和特性。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>配置文件</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gin跨域问题</title>
    <link href="/2023/05/16/gin%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/16/gin%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="gin跨域问题"><a href="#gin跨域问题" class="headerlink" title="gin跨域问题"></a>gin跨域问题</h3><p>作为中间件使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> middleware<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Cors</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>method := context.Request.Method<br>context.Header(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br>context.Header(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;Content-Type,AccessToken,X-CSRF-Token, Authorization, Token&quot;</span>)<br>context.Header(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;POST, GET, OPTIONS&quot;</span>)<br>context.Header(<span class="hljs-string">&quot;Access-Control-Expose-Headers&quot;</span>, <span class="hljs-string">&quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;</span>)<br>context.Header(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>)<br><span class="hljs-keyword">if</span> method == <span class="hljs-string">&quot;OPTIONS&quot;</span> &#123;<br>context.AbortWithStatus(http.StatusNoContent)<br>&#125;<br>context.Next()<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过代码<code>r.Use(middleware.Cors())</code>来使用，但有一点要注意的是，中间件的使用要在路由注册前。否则，跨域中间件使用前注册的路由将不支持跨域。</p><p>像这样是不行的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := setting.Init()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>err = dao.InitMySQL(setting.Conf.MySQLConfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;init mysql failed, err:%v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>r := routers.SetupRouter()<span class="hljs-comment">//路由注册</span><br>r.Use(middleware.Cors())<span class="hljs-comment">//跨域中间件使用</span><br>err = r.Run(fmt.Sprintf(<span class="hljs-string">&quot;:%d&quot;</span>, setting.Conf.Port))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在路由注册的前使用跨域中间件，也可以用他来区分哪些路由支持跨域，哪些不支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetupRouter</span><span class="hljs-params">()</span></span> *gin.Engine &#123;<br>   r := gin.Default()<br><br>   r.Use(middleware.Cors())<span class="hljs-comment">//在这里使用跨域的中间件，下面1,2就可以正常跨域啦。</span><br><br>   r.POST(<span class="hljs-string">&quot;login&quot;</span>, controller.Login)  <span class="hljs-comment">//1</span><br><br>   <span class="hljs-comment">// Ping test</span><br>   r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">//2</span><br>      c.String(http.StatusOK, <span class="hljs-string">&quot;pong&quot;</span>)<br>   &#125;)<br><br>   <span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gin</tag>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的Slice的细节</title>
    <link href="/2023/05/16/Go%E4%B8%AD%E7%9A%84Slice%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <url>/2023/05/16/Go%E4%B8%AD%E7%9A%84Slice%E7%9A%84%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h2 id="Go中的Slice的细节"><a href="#Go中的Slice的细节" class="headerlink" title="Go中的Slice的细节"></a>Go中的Slice的细节</h2><h5 id="源码如下"><a href="#源码如下" class="headerlink" title="源码如下"></a>源码如下</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>array unsafe.Pointer  <span class="hljs-comment">//一个指向数组的指针</span><br><span class="hljs-built_in">len</span>   <span class="hljs-type">int</span>  <span class="hljs-comment">//切片内元素的数量</span><br><span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span>  <span class="hljs-comment">//切片的容量</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/image-20230516013739364.png" alt="image-20230516013739364"></p><p>Go语言是值传递，但一个切片作为参数传递时，会把slice的值复制到另一个slice</p><p><img src="/../img/image-20230516122844623.png" alt="image-20230516122844623"></p><p>通过以下代码可以看出s1作为参数传递给test1后，test1创建了新的副本来承接s1的值，s1和形参slice拥有不同的地址空间，但却拥有相同的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>fmt.Println(<span class="hljs-string">&quot;s1的地址:&quot;</span>, unsafe.Pointer(&amp;s1))  <span class="hljs-comment">//0xc000096060</span><br>fmt.Println(<span class="hljs-string">&quot;s1指向的数组:&quot;</span>, unsafe.Pointer(&amp;s1[<span class="hljs-number">0</span>]))    <span class="hljs-comment">//0xc0000b00f0 </span><br>    <span class="hljs-comment">//s1 cap: 10 s1 len: 1 </span><br>    fmt.Println(<span class="hljs-string">&quot;s1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(s1), <span class="hljs-string">&quot;s1 len:&quot;</span>, <span class="hljs-built_in">len</span>(s1))   <br>test1(s1)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">(s2 []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;形参地址:&quot;</span>, unsafe.Pointer(&amp;s2))    <span class="hljs-comment">//0xc000096078</span><br>fmt.Println(<span class="hljs-string">&quot;形参指向的数组:&quot;</span>, unsafe.Pointer(&amp;s2[<span class="hljs-number">0</span>]))<span class="hljs-comment">//0xc0000b00f0</span><br>    <span class="hljs-comment">//s2 cap: 10 s1 len: 1 </span><br>    fmt.Println(<span class="hljs-string">&quot;s2 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(s2), <span class="hljs-string">&quot;s1 len:&quot;</span>, <span class="hljs-built_in">len</span>(s2))<br>&#125;<br></code></pre></td></tr></table></figure><p>当在函数内对s2指向的数组进行修改时，也会引起s1的改变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>fmt.Println(<span class="hljs-string">&quot;s1修改前:&quot;</span>, s1)<span class="hljs-comment">//[0],int的初始值是0</span><br>test2(s1)<br>fmt.Println(<span class="hljs-string">&quot;s1修改后:&quot;</span>, s1)<span class="hljs-comment">//[1]</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test2</span><span class="hljs-params">(s2 []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;s2修改前:&quot;</span>, s2)<span class="hljs-comment">//[0]</span><br>s2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">2</span>)<br>fmt.Println(<span class="hljs-string">&quot;s2修改后:&quot;</span>, s2)<span class="hljs-comment">//[1,2]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>过程大致如下：</p><p><img src="/../img/image-20230516130425709.png" alt="image-20230516130425709"></p><h4 id="slice扩容机制"><a href="#slice扩容机制" class="headerlink" title="slice扩容机制"></a>slice扩容机制</h4><p>但slice的len等于cap时，使用append往slice追加元素会引发扩容。扩容会开辟一个新的空间，并把原来的数组的值拷贝到新空间。</p><ul><li>cap&lt;1024:新的空间大小是原来的两倍</li><li>cap&gt;1024:为避免浪费内存，新的空间比原来的大1&#x2F;4</li></ul><p>由于扩容后的slice指向的是新的数组，再修改数组上的值，不会引起原数组的改变了。</p><p>值得注意的是，slice的初始值cap过小的话，会频繁的引起扩容，这会带来一定的损耗，过大会引起空间浪费，因此需要合理的初始化slice。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>fmt.Println(<span class="hljs-string">&quot;s1修改前:&quot;</span>, s1)<span class="hljs-comment">//[0]</span><br>test3(s1)<br>fmt.Println(<span class="hljs-string">&quot;s1修改后:&quot;</span>, s1)<span class="hljs-comment">//[0]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test3</span><span class="hljs-params">(s2 []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;扩容前底层数组的地址：&quot;</span>, unsafe.Pointer(&amp;s2[<span class="hljs-number">0</span>])) <span class="hljs-comment">// 0xc0000160c0</span><br>fmt.Println(<span class="hljs-string">&quot;扩容前s2的地址：&quot;</span>, unsafe.Pointer(&amp;s2))  <span class="hljs-comment">// 0xc000004090</span><br>fmt.Println(s2)<span class="hljs-comment">//[0]</span><br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">2</span>)<br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">3</span>)<br>fmt.Println(<span class="hljs-string">&quot;扩容后底层数组的地址：&quot;</span>, unsafe.Pointer(&amp;s2[<span class="hljs-number">0</span>])) <span class="hljs-comment">//0xc00000e200</span><br>fmt.Println(<span class="hljs-string">&quot;扩容前s2的地址：&quot;</span>, unsafe.Pointer(&amp;s2))  <span class="hljs-comment">//0xc000004090</span><br>s2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>fmt.Println(s2)<span class="hljs-comment">//[1,2,3]</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>slice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构积累</title>
    <link href="/2023/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A7%AF%E7%B4%AF/"/>
    <url>/2023/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构积累"><a href="#数据结构积累" class="headerlink" title="数据结构积累"></a>数据结构积累</h2><h3 id="链表篇"><a href="#链表篇" class="headerlink" title="链表篇"></a>链表篇</h3><h4 id="链表的遍历："><a href="#链表的遍历：" class="headerlink" title="链表的遍历："></a>链表的遍历：</h4><h5 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="1.层序遍历"></a>1.层序遍历</h5><p>依靠队列轻松实现</p><p><img src="D:\Blog\source\img\image-20230515132047472.png" alt="image-20230515132047472"></p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//存放结果的数组</span><br>    ans:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">//判断是否为空的二叉树</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">return</span> ans<br>    &#125;<br>    <span class="hljs-comment">//模拟队列的数组</span><br>    queue:=[]*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span>&#123;<br>        <span class="hljs-comment">//队列为空，循环结束</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue)==<span class="hljs-number">0</span>&#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-comment">//将队头的值加入数组</span><br>        ans=<span class="hljs-built_in">append</span>(ans,queue[<span class="hljs-number">0</span>].Val )<br>        <span class="hljs-comment">//将队头的左子节点加入队尾</span><br>        <span class="hljs-keyword">if</span> queue[<span class="hljs-number">0</span>].Left!=<span class="hljs-literal">nil</span>&#123;<br>            queue=<span class="hljs-built_in">append</span>(queue,queue[<span class="hljs-number">0</span>].Left)<br>        &#125;<br>        <span class="hljs-comment">//将队头的右子节点加入队尾</span><br>        <span class="hljs-keyword">if</span> queue[<span class="hljs-number">0</span>].Right!=<span class="hljs-literal">nil</span>&#123;<br>            queue=<span class="hljs-built_in">append</span>(queue,queue[<span class="hljs-number">0</span>].Right)<br>        &#125;<br>        <span class="hljs-comment">//队头取出</span><br>        queue=queue[<span class="hljs-number">1</span>:]<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分享实用的小工具</title>
    <link href="/2023/05/11/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"/>
    <url>/2023/05/11/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="绘图工具"><a href="#绘图工具" class="headerlink" title="绘图工具"></a>绘图工具</h3><p><a href="https://excalidraw.com/">https://excalidraw.com/</a></p><p>一个画风清新的在线小白板，操作简单易上手。还有丰富的素材库，轻轻松松绘出美观的流程图。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="/../img/image-20230512181343591.png" alt="image-20230512181343591"></p><h4 id="推荐几个计算机专业时常用到的素材库"><a href="#推荐几个计算机专业时常用到的素材库" class="headerlink" title="推荐几个计算机专业时常用到的素材库"></a>推荐几个计算机专业时常用到的素材库</h4><p>点击上图右上方素材库，进入素材库，然后点击浏览素材库。然后把下方库名复制到搜索框进行搜索，然后添加即可</p><h5 id="Algorithms-and-Data-Structures"><a href="#Algorithms-and-Data-Structures" class="headerlink" title="Algorithms and Data Structures"></a>Algorithms and Data Structures</h5><p><img src="/../img/image-20230512181854115.png" alt="image-20230512181854115"></p><p>这个素材库提供了多种数据结构的简图，包含了数组、链表、Map、树等等。平写算法题时可以用来梳理思路，或者写题解。</p><h5 id="Shapes-for-UML-amp-ER-Diagrams"><a href="#Shapes-for-UML-amp-ER-Diagrams" class="headerlink" title="Shapes for UML &amp; ER Diagrams"></a>Shapes for UML &amp; ER Diagrams</h5><p><img src="/../img/image-20230512182458083.png" alt="image-20230512182458083"></p><p>绘制用例图和ER图，做需求分析时也时常用到。</p>]]></content>
    
    
    <categories>
      
      <category>小工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>绘图工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitee使用简易教程</title>
    <link href="/2023/03/30/Gitee%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
    <url>/2023/03/30/Gitee%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Gitee使用简易教程"><a href="#Gitee使用简易教程" class="headerlink" title="Gitee使用简易教程"></a>Gitee使用简易教程</h3><p>老师要求在gitee上提交作业的，对于没使用过Gitee的同学来说，可能一开始会有点复杂。可以按照以下方式进行。</p><h5 id="1-在Gitee上新建仓库："><a href="#1-在Gitee上新建仓库：" class="headerlink" title="1.在Gitee上新建仓库："></a>1.在Gitee上新建仓库：</h5><p>1.登录后在屏幕的右上角有个加号，鼠标悬停出现“新建仓库”</p><p><img src="/../img/image-20230330130743940.png" alt="image-20230330130743940"></p><p>2.点击新建仓库，进入如下界面，编辑仓库的名称和路径即可，至于初始化，先都不选择，点击创建。</p><p><img src="/../img/image-20230330130919059.png" alt="image-20230330130919059"></p><p>创建成功后进入到如下界面：</p><p><img src="/../img/image-20230330140242916.png" alt="image-20230330140242916"></p><p><strong>这是官方的入门教程，里面的代码可以直接使用。但事先需要在自己电脑上安装git。不要关闭这个页面，后面会用到。先进行后面的操作。</strong></p><h5 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h5><p>如果已经安装，可以跳过。</p><p><a href="https://www.cnblogs.com/ybqjymy/p/17226628.html">参考连接</a></p><h5 id="3-提交"><a href="#3-提交" class="headerlink" title="3.提交"></a>3.提交</h5><p>按照老师的文档创建Vue项目，进入到该项目的目录下，右击空白处，选择“Git Bash Here”打开命令行。</p><p><img src="/../img/image-20230330131546570.png" alt="image-20230330131546570"></p><p>首先需要进行的是全局设置：正如先前提到，此处可以直接使用你自己创建Gitee仓库时,官方给出的代码，无需修改。格式如下，在Gitee上创建仓库后的教程里找到对应的代码复制到命令行即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>由于我之前安装过git,在按照老师的的文档生成作的项目已经是一个仓库了，所以我们没选择初始化。而是直接进行以下操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;commit login_demo&quot;</span><br>git remote add origin https://gitee.com/lin-yegui/demo.git //这里换成自己的项目路径<br>git push -u origin <span class="hljs-string">&quot;master&quot;</span><br></code></pre></td></tr></table></figure><p>如果你是先在本地完成项目的创建后下的git,在执行以上代码时，命令行会提醒你进行初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>初始化成功后执行以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><p>如果出现以下错误：</p><p><img src="/../img/image-20230330154513629.png" alt="image-20230330154513629"></p><p>执行以下代码，后再执行<code>git status</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-built_in">config</span> --global --<span class="hljs-keyword">add </span>safe.<span class="hljs-keyword">directory </span><span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><p>当看到类似如下界面时，问题就被解决了。</p><p><img src="/../img/image-20230330142029806.png" alt="image-20230330142029806"></p><p>用如下命令追踪所有新加入的文件，然后提交，提交的信息和双引号格外主义需要英文</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;本次提交的说明写在这里&quot;</span> <br></code></pre></td></tr></table></figure><p>然后合并到远程仓库：这里的也可以直接使用官方的入门教程里的代码。格式如下，在Gitee上创建仓库后的教程里找到对应的代码复制到命令行即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote add origin https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/lin-yegui/</span>demo.git <span class="hljs-regexp">//</span>这里换成自己的项目路径<br>git push -u origin <span class="hljs-string">&quot;master&quot;</span><br></code></pre></td></tr></table></figure><p>执行<code>git push -u origin &quot;master&quot;</code>后会弹出一个登录界面，输入你的gitee账号密码即可。</p><p>掌握以上内容基本上可以完成本次作业的提交了，关于git的使用还有很多，以后用到的时候再慢慢查吧。</p><p><a href="https://www.runoob.com/git/git-remote.html">菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程与进程的区别</title>
    <link href="/2023/03/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2023/03/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h3 id="理解线程与进程的区别"><a href="#理解线程与进程的区别" class="headerlink" title="理解线程与进程的区别"></a>理解线程与进程的区别</h3><p>进程：是操作系统进行资源分配和保护的单位。</p><p>线程：是处理器调度和分配的基本单位。</p><p>下图是一个进程的组成，一个进程通常包含一个或多个线程。</p><p><img src="/../img/image-20230228213607224.png" alt="image-20230228213607224"></p><p>可以直观的看出，线程的存在使得处理器调度时，同一进程内的线程调度只需要完成用户栈和核心栈等少部分资源的切换。与进程切换相比节省了很多开销。</p><h3 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>用户级线程是指线程的管理工作有应用程序来做，在用户空间内实现，因此内核不知道线程的存在，进程才是处理器的基本单位。用户线程的切换不会陷入操作系统，省去了用户态—内核态—用户态模式切换的开销，但一个用户级线程的阻塞将引起整个进程的阻塞。Jeckting技术可以让操作系统在发现进程将要进入等待态时，可以让用户级线程的调度器选择下一线程占有处理器运行。</p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>线程的调度和管理由在内核中实现，内核可感知线程的存在并且以线程为单位进行处理器调度，一个进程里的某个线程阻塞时，其他的线程仍可以被调度。但每次调度需要用户态—内核态—用户态模式切换的开销。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce是如何工作的？</title>
    <link href="/2023/03/11/MapReduce%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/"/>
    <url>/2023/03/11/MapReduce%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="MapReduce是如何工作的？"><a href="#MapReduce是如何工作的？" class="headerlink" title="MapReduce是如何工作的？"></a>MapReduce是如何工作的？</h2><h4 id="这篇主要是根据个人理解，就着原文的例子，对MapReduce的执行过程有个更加直观的感受。"><a href="#这篇主要是根据个人理解，就着原文的例子，对MapReduce的执行过程有个更加直观的感受。" class="headerlink" title="这篇主要是根据个人理解，就着原文的例子，对MapReduce的执行过程有个更加直观的感受。"></a>这篇主要是根据个人理解，就着原文的例子，对MapReduce的执行过程有个更加直观的感受。</h4><p><img src="/../img/image-20230311164022116.png"></p><ol><li><h5 id="创建程序副本"><a href="#创建程序副本" class="headerlink" title="创建程序副本"></a>创建程序副本</h5><p>用户程序首先调用的MapReduce库将输入文件分成M个数据片度，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量的程序副本。 </p></li><li><h5 id="为程序副本分配任务"><a href="#为程序副本分配任务" class="headerlink" title="为程序副本分配任务"></a>为程序副本分配任务</h5><p>这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是worker程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。</p></li><li><h5 id="执行Map函数"><a href="#执行Map函数" class="headerlink" title="执行Map函数"></a>执行Map函数</h5><p>被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key&#x2F;value pair，然后把key&#x2F;value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key&#x2F;value pair，并缓存在内存中。</p></li><li><h5 id="存储中间key-x2F-value-pair"><a href="#存储中间key-x2F-value-pair" class="headerlink" title="存储中间key&#x2F;value pair"></a>存储中间key&#x2F;value pair</h5><p>缓存中的key&#x2F;value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key&#x2F;value pair在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。</p></li><li><h5 id="聚合数据"><a href="#聚合数据" class="headerlink" title="聚合数据"></a>聚合数据</h5><p>当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</p></li><li><h5 id="执行Reduce函数"><a href="#执行Reduce函数" class="headerlink" title="执行Reduce函数"></a>执行Reduce函数</h5><p>Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。</p></li><li><h5 id="返回MapReduce调用"><a href="#返回MapReduce调用" class="headerlink" title="返回MapReduce调用"></a>返回MapReduce调用</h5><p>当所有的Map和Reduce任务都完成之后，master唤醒用户程序。在这个时候，在用户程序里的对MapReduce调用才返回。</p></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>计算一个大的文档集合中每个单词出现的次数，下面是伪代码段：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">map</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>, <span class="hljs-built_in">String</span> value):<br>    <span class="hljs-comment">// key: document name</span><br>    <span class="hljs-comment">// value: document contents</span><br>    <span class="hljs-keyword">for</span> each word w in value:<br>        <span class="hljs-title function_">EmitIntermediate</span>(w, “<span class="hljs-number">1</span>″);<br><span class="hljs-title function_">reduce</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>, Iterator values):<br>    <span class="hljs-comment">// key: a word</span><br>    <span class="hljs-comment">// values: a list of counts</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> each v in values:<br>        result += <span class="hljs-title function_">ParseInt</span>(v);<br>    <span class="hljs-title function_">Emit</span>(<span class="hljs-title function_">AsString</span>(result));<br></code></pre></td></tr></table></figure><p>有如下文本段</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d d f f g g <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> d c g <span class="hljs-selector-tag">b</span>&quot; <br></code></pre></td></tr></table></figure><p>假设这是份很大的数据，我们不得已将他分成更小的部分，以便我们的机器能够处理它</p><p>于是乎他被分成了两部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">key1   &quot;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d d&quot;<br>key2   &quot;f f g g <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> d c g <span class="hljs-selector-tag">b</span>&quot; <br></code></pre></td></tr></table></figure><p>按照MapReduce的计划，它们将被分到不同两个机子上存起来</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">ComputerA  &#123;key1,&quot;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d d&quot;&#125;<br>ComputerB  &#123;key2,&quot;f f g g <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> d c g <span class="hljs-selector-tag">b</span>&quot;&#125; <br></code></pre></td></tr></table></figure><p>当用户调用MapReduce时，会在集群中创建大量的worker程序副本和一个master</p><p>master会优先让存储有输入文件的机器执行map任务。该机器上的worker程序把数据片段传递给map执行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">ComputerA :&#123;key1,&quot;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d d&quot;&#125; ---&gt; workerA---&gt;map(key1,&quot;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> d d&quot;)<br>ComputerB :&#123;key2,&quot;f f g g <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> d c g <span class="hljs-selector-tag">b</span>&quot;&#125; ---&gt; workerB---&gt;map(key2,&quot;f f g g <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> d c g <span class="hljs-selector-tag">b</span>&quot;)<br></code></pre></td></tr></table></figure><p>得到中间键值对：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>d</th><th>d</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><table><thead><tr><th>f</th><th>f</th><th>g</th><th>g</th><th>a</th><th>a</th><th>d</th><th>c</th><th>g</th><th>b</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>假设分区数量R为2，根据hash(key) mod R将得到</p><p>ComputerA ：</p><p>分区R1：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>分区R2：</p><table><thead><tr><th>d</th><th>d</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr></tbody></table><p>ComputerB ：</p><p>分区R1：</p><table><thead><tr><th>a</th><th>a</th><th>c</th><th>b</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>分区R2：</p><table><thead><tr><th>f</th><th>f</th><th>g</th><th>g</th><th>d</th><th>g</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>master程序把这些分区后的数据的存储位置告诉执行Reduce的worker,worker把自己分区内的中间key&#x2F;valie pair收集。全部收集后如下</p><p>Reduce worker1：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>a</th><th>a</th><th>c</th><th>b</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>Reduce worker2：</p><table><thead><tr><th>d</th><th>d</th><th>f</th><th>f</th><th>g</th><th>g</th><th>d</th><th>g</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>排序聚合后：有时候在执行map任务后就可以通过Combiner函数，在Reduce收集中间数据时便完成排序。</p><table><thead><tr><th>a</th><th>a</th><th>a</th><th>a</th><th>a</th><th>b</th><th>b</th><th>b</th><th>b</th><th>c</th><th>c</th><th>c</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><table><thead><tr><th>d</th><th>d</th><th>d</th><th>f</th><th>f</th><th>g</th><th>g</th><th>g</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>最后，以key:a value:{1,1,1,1,1}作为参数，交给Reduce。得到 a : 5</p><h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><p>有时候在执行map任务后就可以通过Combiner函数，在Reduce收集中间数据时便完成排序。部分的合并中间结果可以显著的提高一些MapReduce操作的速度。</p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
      <tag>执行过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统简介</title>
    <link href="/2023/03/10/6.824%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/03/10/6.824%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>这是个人在学习 <strong>MIT6.824 分布式系统</strong>时的个人总结。</p><h3 id="6-824-分布式系统"><a href="#6-824-分布式系统" class="headerlink" title="6.824 分布式系统"></a>6.824 分布式系统</h3><h5 id="分布式系统的核心：是一系列计算集群通过网络共同完成某一串连贯的任务"><a href="#分布式系统的核心：是一系列计算集群通过网络共同完成某一串连贯的任务" class="headerlink" title="分布式系统的核心：是一系列计算集群通过网络共同完成某一串连贯的任务"></a>分布式系统的核心：是一系列计算集群通过网络共同完成某一串连贯的任务</h5><h4 id="分布式计算为什么那么重要"><a href="#分布式计算为什么那么重要" class="headerlink" title="分布式计算为什么那么重要"></a>分布式计算为什么那么重要</h4><p>曾经，Google 构造过一个系统，这个系统要在TB级的数据上进行大量计算，比如创建所有网页内容的索引或分析整个网络的链接结构以便识别出最重要的页面或最权威的页面，正如大家知道的那样。</p><p>那时，整个网络甚至有，数十TB的数据，构建网络索引基本上等于跑遍所有的数据，这是相当耗时的。倘若在单台电脑上运算（计算量远远超出单台当时最好的单台计算机的计算能力），可能要花几周，几个月或几年，甚至更多。</p><p>Google当时是极其渴望能在数以千计的计算机上进行巨型数据计算以便计算可以快速完成。</p><p>因为相比于让一台计算机的计算能力翻倍，再购买一台计算机的成本要低的多得多。</p><p>我们希望构建一个这样一个系统：随着集群中的计算机越来越来越多，集群的计算能力越来越强。例如，原本在一个机子上运行10天能才能解决的问题，在一个由10个机子组成的集群中，我们希望他只花一天，并且随着集群的扩展，运算能力也能随之增强。</p><h5 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h5><p><a href="https://developer.aliyun.com/article/31829#slide-7">MapReduce译文</a></p><p><a href="http://labs.google.com/papers/mapreduce.html">MapReduce原文</a></p><p>MapReduce的个人总结</p><h3 id="容错问题"><a href="#容错问题" class="headerlink" title="容错问题"></a>容错问题</h3><p>一台计算机稳定的运行一年不是一件难事，但在数千台计算机组成的集群中，近乎每天都会发生个别计算机的故障（假设一台电脑平均运行1年会发生崩溃，也就是没365天崩溃一次，那在1000台电脑中，（1&#x2F;365）*1000&#x3D;2.74，每天近3台电脑发生崩溃）。因此，大型分布式系统，把一个很罕见的错误转变成常见的错误。</p><p>分布式系统中，总有一些机器会崩溃或者神秘地错误运行了。在一千台计算机的网络中，有许多的网络电缆，许多的网络交换机，要知道，现实中是会有人会踩着电缆的，或者某些交换机风扇损坏而导致不能正常工作。</p><p>故而，分布式系统应当对这些错误有着正确处理方式，来保证在个别主机出现问题时，仍然能够提供正常的服务。</p><h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><h5 id="虽然分布式系统有着高性能，高容错等优点，但要知道，这也意味着实现分布式系统是件极其复杂的工作，因此我们这设计一个系统时，一定要慎重考虑它是否能在单机系统上得到较好的解决，如果可以，进来避免采用分布式。"><a href="#虽然分布式系统有着高性能，高容错等优点，但要知道，这也意味着实现分布式系统是件极其复杂的工作，因此我们这设计一个系统时，一定要慎重考虑它是否能在单机系统上得到较好的解决，如果可以，进来避免采用分布式。" class="headerlink" title="虽然分布式系统有着高性能，高容错等优点，但要知道，这也意味着实现分布式系统是件极其复杂的工作，因此我们这设计一个系统时，一定要慎重考虑它是否能在单机系统上得到较好的解决，如果可以，进来避免采用分布式。"></a>虽然分布式系统有着高性能，高容错等优点，但要知道，这也意味着实现分布式系统是件极其复杂的工作，因此我们这设计一个系统时，一定要慎重考虑它是否能在单机系统上得到较好的解决，如果可以，进来避免采用分布式。</h5>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅的做一个班长</title>
    <link href="/2022/12/10/%E7%94%A8pandas%E5%A4%84%E7%90%86%E8%A1%A8%E6%A0%BC/"/>
    <url>/2022/12/10/%E7%94%A8pandas%E5%A4%84%E7%90%86%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="用pandas处理表格"><a href="#用pandas处理表格" class="headerlink" title="用pandas处理表格"></a>用pandas处理表格</h2><p>作为一名班干，经常要帮助辅导员从同学们手上收集各种表格，还有从全学院或者全校的学生信息出挑出本班同学的信息让同学们核对，故经常出现一下情况：</p><ul><li>收集了大部分同学时，有小部分同学没有收集，筛查比较麻烦</li><li>在从上万条信息中筛选出本班同学信息，在同学们的信息填写完整时，还是比较容易用Excel筛选出来，但总有小部分同学信息不完善，又会漏掉。</li><li>需要抽少部分同学去完成某项任务</li></ul><p>python中的pandas可以很方便的帮助我们完成表格数据的对比。</p><p>值得注意的是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pandas.read_excel(filename, sheet_name=<span class="hljs-number">0</span>)<span class="hljs-comment">#慢</span><br><br>pandas.read_csv(filename, encoding=<span class="hljs-string">&quot;gbk&quot;</span>)<span class="hljs-comment">#快</span><br></code></pre></td></tr></table></figure><p>read_csv的执行效率很快，但是生成的CSV文件在手机不能直接预览，即使后面再用Excel修改文件类型后仍有问题，而大部分学生收到通知都是在手机，故很不方便。</p><p>一开始用一下代码来检查文件与学生信息的包含关系是，总是要执行<code>pandas.read_excel(filename, sheet_name=0)</code>，很慢,比CSV的打开慢10倍不止。</p><p>后来干脆弃用这个函数，直接把for循环提出来写到调用的地方，这样就只用打开一次文件了，效率大大增加了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">contain</span>(<span class="hljs-params">filename, index, name</span>):<br>    file = pandas.read_excel(filename, sheet_name=<span class="hljs-number">0</span>).values<br>    <span class="hljs-comment"># file = pandas.read_csv(filename, encoding=&quot;gbk&quot;).values</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file)):<br>        <span class="hljs-keyword">if</span> file[i][index] == name:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>后面附上代码，抽签的也有，喜欢的班干可以拿去修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是一个示例 Python 脚本。</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pandas<br><span class="hljs-keyword">import</span> csv<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">contain</span>(<span class="hljs-params">filename, index, name</span>):<br>    file = pandas.read_excel(filename, sheet_name=<span class="hljs-number">0</span>).values<br>    <span class="hljs-comment"># file = pandas.read_csv(filename, encoding=&quot;gbk&quot;).values</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file)):<br>        <span class="hljs-keyword">if</span> file[i][index] == name:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># index为名字所在列的下标</span><br><span class="hljs-comment"># 文件1和文件2中都有的</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">whoFinish</span>(<span class="hljs-params">filename1, index1, filename2, index2</span>):<br>    file1 = pandas.read_excel(filename1, sheet_name=<span class="hljs-number">0</span>).values<br>    file2 = pandas.read_excel(filename2, sheet_name=<span class="hljs-number">0</span>).values<br>    data = []<br>    filename = time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d-%H-%M-%S&#x27;</span>)<br>    filename = filename + <span class="hljs-string">&quot;.xlsx&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file1)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file2)):<br>            <span class="hljs-built_in">print</span>(file1[i][index1])<br>            <span class="hljs-keyword">if</span> file2[j][index2] == file1[i][index1]:<br>                data.append(file1[i])<br>    data = pandas.DataFrame(data)<br>    data.to_excel(filename, index=<span class="hljs-literal">False</span>)<br><br><span class="hljs-comment">#文件1中有，文件2中没有</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">whoNotFinish</span>(<span class="hljs-params">filename1, index1, filename2, index2</span>):<br>    file1 = pandas.read_excel(filename1, sheet_name=<span class="hljs-number">0</span>).values<br>    file2 = pandas.read_excel(filename2, sheet_name=<span class="hljs-number">0</span>).values<br>    data = []<br>    message = <span class="hljs-string">&quot;请上同学尽快完成&quot;</span><br>    filename = time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d-%H-%M-%S&#x27;</span>)<br>    filename = filename + <span class="hljs-string">&quot;.xlsx&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file1)):<br>        flag = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(file2)):<br>            <span class="hljs-keyword">if</span> file2[j][index2] == file1[i][index1]:<br>                flag = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>:<br>            data.append(file1[i])<br>            message = <span class="hljs-string">&quot;@&quot;</span> + file1[i][index1] + <span class="hljs-string">&quot;,\n&quot;</span> + message<br>    data = pandas.DataFrame(data)<br>    <span class="hljs-comment"># data.to_excel(filename, index=False)</span><br>    <span class="hljs-built_in">print</span>(message)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">list1, str1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(list1)):<br>        <span class="hljs-keyword">if</span> str1 == list1[i]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mixlot</span>(<span class="hljs-params">stuNumber</span>):<br>    data = pandas.read_csv(<span class="hljs-string">&quot;抽签.csv&quot;</span>, encoding=<span class="hljs-string">&quot;gbk&quot;</span>)<br>    stus = data.values<br>    lucky = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(lucky) &lt; stuNumber:<br>        stu = stus[random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(stus) - <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">if</span> check(lucky, stu[<span class="hljs-number">0</span>]):<br>            lucky.append(stu[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> lucky<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lot</span>(<span class="hljs-params">nboy, ngirl, </span>):<br>    <span class="hljs-comment"># 在下面的代码行中使用断点来调试脚本。</span><br>    data = pandas.read_csv(<span class="hljs-string">&quot;抽签.csv&quot;</span>, encoding=<span class="hljs-string">&quot;gbk&quot;</span>)<br>    stus = data.values<br>    girls = []<br>    boys = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(data)):<br>        <span class="hljs-keyword">if</span> stus[i][<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;女&#x27;</span>:<br>            girls.append(stus[i][<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">else</span>:<br>            boys.append((stus[i][<span class="hljs-number">0</span>]))<br>    <span class="hljs-comment"># print(len(stus))</span><br>    <span class="hljs-comment"># print(len(boys))</span><br>    <span class="hljs-comment"># print(len(girls))</span><br>    lucky_boys = []<br>    lucky_girls = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(lucky_boys) &lt; nboy:<br>        boy = boys[random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(boys) - <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">if</span> check(lucky_boys, boy):<br>            lucky_boys.append(boy)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(lucky_girls) &lt; ngirl:<br>        girl = girls[random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(girls) - <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">if</span> check(lucky_girls, girl):<br>            lucky_girls.append(girl)<br>    <span class="hljs-keyword">return</span> lucky_girls, lucky_boys<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># print(&quot;抽签将在2分钟后完成&quot;)</span><br>    <span class="hljs-comment"># print(&quot;现在的时间是：&quot;)</span><br>    <span class="hljs-comment"># print(time.ctime(time.time()))</span><br>    <span class="hljs-comment"># time.sleep(0)</span><br>    <span class="hljs-comment"># print(&quot;抽签结束，结果如下&quot;)</span><br>    <span class="hljs-comment"># print(&quot;现在的时间是：&quot;)</span><br>    <span class="hljs-comment"># print(time.ctime(time.time()))</span><br>    <span class="hljs-comment"># print(lot(1,0))</span><br>    <span class="hljs-comment"># print(mixlot(2))</span><br><br>     <span class="hljs-comment">#whoFinish(&quot;221208秋季学期老生形策课线上课成绩.xlsx&quot;,2,&quot;抽签.xlsx&quot;,0)</span><br>     whoNotFinish(<span class="hljs-string">&quot;抽签.xlsx&quot;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&quot;2020级班级情况表.xlsx&quot;</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO的面向接口</title>
    <link href="/2022/10/31/GO%E7%9A%84%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/10/31/GO%E7%9A%84%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GO的面向对象</title>
    <link href="/2022/10/31/GO%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/10/31/GO%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/20/hello-world/"/>
    <url>/2022/10/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go的单元测试</title>
    <link href="/2022/10/20/%E5%85%B3%E4%BA%8EGO%E7%9A%84%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/10/20/%E5%85%B3%E4%BA%8EGO%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="单元测试的意义"><a href="#单元测试的意义" class="headerlink" title="单元测试的意义"></a>单元测试的意义</h3><p>软件系统是由许多个单元构成的，这些单元可能是对象、类、 函数，或者是一个更大的单元——组件或者模块。软件系统的整体质量就是由各个单元的质量保证，通过充分的单元测试，发现并修正单元中的问题，从而为系统的质量打下基础。</p><h3 id="单元测试的工具"><a href="#单元测试的工具" class="headerlink" title="单元测试的工具"></a>单元测试的工具</h3><p>单元测试一般针对程序代码进行测试，因此测试工具和特定的编程语言密切相关。典型的就是<code>xxxUnit</code>工具家族</p><p>例如：</p><ul><li><code>Junit</code> for JAVA</li><li><code>CppUnit</code> for C++</li><li><code>NUnit</code> for C#(.NET)</li></ul><h6 id="而GO语言则是通过标准库testing进行单元测试的"><a href="#而GO语言则是通过标准库testing进行单元测试的" class="headerlink" title="而GO语言则是通过标准库testing进行单元测试的"></a>而GO语言则是通过标准库<code>testing</code>进行单元测试的</h6><h3 id="GO的单元测试"><a href="#GO的单元测试" class="headerlink" title="GO的单元测试"></a>GO的单元测试</h3><p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 <code>_test.go</code> 结尾。比如，当前 package 有 <code>calc.go</code> 一个文件，我们想测试 该文件里的单元（通常是函数），那么应该新建 <code>calc_test.go</code> 作为测试文件（<code>GoLand</code>中右击需要测试的文件，选择<code>go to</code>下的<code>testing</code>即可生成）。</p><p>在测试文件内有三种函数。</p><table><thead><tr><th><strong>类型</strong></th><th><strong>格式</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>测试函数</td><td>函数名前缀为Test</td><td>测试程序的一些逻辑行为是否正确</td></tr><tr><td>基准函数</td><td>函数名前缀为Benchmark</td><td>测试函数的性能</td></tr><tr><td>示例函数</td><td>函数名前缀为Example</td><td>为文档提供示例文档</td></tr></tbody></table><h6 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h6><p>在<code>GoLand</code>中右击需要测试的函数，选择<code>go to</code>下的<code>testing</code>即可生成对应的测试函数（不同控制状态下的函数生成对应的测试函数名不同，<code>Add</code>会生成<code>TestAdd</code>而<code>add</code>则生成<code>Test_add</code>，不过均以Test作为前缀）</p><p>Add函数如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> ex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的对应的测试函数如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> ex<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdd</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">//参数结构体</span><br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int</span><br>b <span class="hljs-type">int</span><br>&#125;<br>    <span class="hljs-comment">//测试结构体，每一例测试包含了名字和参数和期望输出</span><br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span>  <br>want <span class="hljs-type">int</span><br>        args args<br>&#125;&#123;<br>        <span class="hljs-comment">// (在此处添加测试样例)<span class="hljs-doctag">TODO:</span> Add test cases.</span><br>&#125;<br>    <span class="hljs-comment">//遍历测试样例，分别执行</span><br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>            <span class="hljs-comment">//在测试样例的参数传进去，返回的结果与期望比较，不同的话调用Errorf输出</span><br><span class="hljs-keyword">if</span> got := Add(tt.args.a, tt.args.b); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;Add() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，测试函数的参数只有一个 <code>t testing.t</code>,他用于报告测试失败和附加的日志信息。 <code>testing.T</code>的拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Error(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Errorf(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Fail()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> FailNow()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Failed() <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Fatal(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Fatalf(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Log(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Logf(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Name() <span class="hljs-type">string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Parallel()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Run(name <span class="hljs-type">string</span>, f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span>) <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Skip(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> SkipNow()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Skipf(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span></span> Skipped() <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p>查看测试覆盖率：在命令行终端执行<code>go test -cover -coverprofile=d</code>后，会在当前目录下生成一个文件d</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -cover -coverprofile=d<br>--- FAIL: TestAdd (0.00s)                <br>    --- FAIL: TestAdd/1+2 (0.00s)        <br>        add_test.go:20: Add() = 3, want 4<br>--- FAIL: TestSolution (0.00s)                  <br>    非空子序列_test.go:31: expected:&#123;3&#125;, got:&#123;4&#125;<br>FAIL                                            <br>coverage: 100.0% of statements                  <br><span class="hljs-built_in">exit</span> status 1                         <br>FAIL    awesomeProject/ex       0.209s<br><br></code></pre></td></tr></table></figure><p>使用 <code>go tool cover -html=d </code>，即可在浏览器中打开查看详细情况。</p><p><img src="/../image/image-20221018175049523.png"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>本文只是简单的讲了如何在Go中进行单元测，同步学校的软件测试课程（课上讲的是JUnit，自己跟倾向go方向），后面会随着课程的推进不断完善，例子和操作的是一些最基础的，想要写出高质量的代码，就不得不编写更多刁钻的测试用例和测试代码，来不断测试并完善自己的代码。</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p><a href="https://www.liwenzhou.com/posts/Go/unit-test/#autoid-2-4-0">李文周的博客</a></p><p><a href="https://geektutu.com/post/quick-go-test.html">极客兔兔</a></p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用git删除GitHub上的项目内的文件</title>
    <link href="/2022/09/30/%E4%BD%BF%E7%94%A8git%E5%88%A0%E9%99%A4%E9%A1%B9%E7%9B%AE%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <url>/2022/09/30/%E4%BD%BF%E7%94%A8git%E5%88%A0%E9%99%A4%E9%A1%B9%E7%9B%AE%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="使用git删除GitHub上的项目内的文件"><a href="#使用git删除GitHub上的项目内的文件" class="headerlink" title="使用git删除GitHub上的项目内的文件"></a>使用git删除GitHub上的项目内的文件</h4><h5 id="首先把项目拉倒克隆到本地"><a href="#首先把项目拉倒克隆到本地" class="headerlink" title="首先把项目拉倒克隆到本地:"></a>首先把项目拉倒克隆到本地:</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/linyegui/linyegui.github.io.git<br></code></pre></td></tr></table></figure><h5 id="进入项目文件的分支里运行git-bash"><a href="#进入项目文件的分支里运行git-bash" class="headerlink" title="进入项目文件的分支里运行git bash"></a>进入项目文件的分支里运行git bash</h5><p>使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.email <span class="hljs-string">&quot;youremail&quot;</span><br>$ git config --global user.name <span class="hljs-string">&quot;emailname&quot;</span><br>$ <span class="hljs-built_in">dir</span><br>$ git <span class="hljs-built_in">rm</span> -r --cached text<br>$ git commit -m <span class="hljs-string">&#x27;remove text&#x27;</span><br>$ git push -u origin main     //提交到远程仓库<br><br></code></pre></td></tr></table></figure><p>提交很有可能超时，必要时记得科学上网</p><h5 id="也可使用cd命令进入："><a href="#也可使用cd命令进入：" class="headerlink" title="也可使用cd命令进入："></a>也可使用cd命令进入：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> filename //进入当前目录下名为filename的子目录<br>$ <span class="hljs-built_in">cd</span> ..       //回到当前目录的父级目录<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
